[{"path":"https://leejasme.github.io/staRgate/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 staRgate authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Tutorial: Running the pipeline","text":"{staRgate} package relies Biocondcutor R packages. installing {staRgate}, first setup Bioconductor install dependencies. instructions instructions installing Bioconductor install staRgate:","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(version = \"3.19\")  BiocManager::install(c(\"openCyto\",                        \"flowAI\",                        \"flowCore\",                        \"flowWorkspace\",                        \"ggcyto\")) devtools::install_github(\"leejasme/staRgate\")"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Tutorial: Running the pipeline","text":"essential dependencies running {staRgate} package include: {flowCore}, {flowWorkspace}. following packages needed fully run pipeline shown Tutorial, required {staRgate} code chunks run: {openCyto}, {flowAI}, {ggplot2}, {ggCyto}, {gt} Insert explanation parameters entire pipeline, fig workflow pipeline input files expected comma-separated values (csv) files Comp mat Biexp transformation parameters Gating template things keep mind debugging/iterating gating: saving path name (.e., rerunning code), GatingSet folder flowWorkspace::save_gs() command needs deleted {openCyto} save , otherwise, encounter error related invalid path flowWorkspace::save_gs() function","code":"# Load libraries library(staRgate) library(openCyto) library(flowWorkspace) #> As part of improvements to flowWorkspace, some behavior of #> GatingSet objects has changed. For details, please read the section #> titled \"The cytoframe and cytoset classes\" in the package vignette: #>  #>   vignette(\"flowWorkspace-Introduction\", \"flowWorkspace\") library(flowCore) # Just for plotting in the vignette library(ggplot2)  # Set up dynamic variables  ## Below are examples # ## String: sample name # pt_samp_nm = \"flow_sample_1\" #  # ## File path to the FCS file # path_fcs = \"./flow_sample_1.fcs\" #  # ## File path to the compensation matrix csv file # ## Expect format to match flowJo exported version # path_comp_mat = \"./flow_sample_1_comp_mat.csv\" #  # ## File path for outputs/saving # path_out = \"./output\" #  # ## File path to gating template # gtFile = \"./flow_tcell_gating_template.csv\" #  # ## File path to biexp parameters # ## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec # ## full name should contain the channel/dye name # #3 remaining cols fill in with desired parameter values # path_biexp_params = \"./flow_biexp_param.csv\" # ## File path to positive peak thresholds # path_pos_peak_thresholds = \"./pos_peak_thresholds.csv\"  # After adding inst/extdata pt_samp_nm = \"flow_sample_1\"  ## File path to the FCS file path_fcs = system.file(\"extdata\", \"example_fcs.fcs\", package = \"staRgate\", mustWork = TRUE)  ## File path to the compensation matrix csv file ## Expect format to match flowJo exported version path_comp_mat = system.file(\"extdata\", \"comp_mat_example_fcs.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path for outputs/saving # Maybe not the best sol, but create a temp dir? path_out = tempdir() # Print the path_out for user to see path_out #> [1] \"/tmp/Rtmpy8VKGb\"  ## File path Gating template gtFile = system.file(\"extdata\", \"gating_template_x50_tcell.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path to biexp parameters ## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec ## full name should contain the channel/dye name #3 remaining cols fill in with desired parameter values path_biexp_params = system.file(\"extdata\", \"biexp_transf_parameters_x50.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path to positive peak thresholds path_pos_peak_thresholds = system.file(\"extdata\", \"pos_peak_thresholds.csv\", package = \"staRgate\", mustWork = TRUE) # Some preferred ggplot settings.  # Not required/relevant for gating  plot_font_size = 13  ggplot2::theme_set(ggplot2::theme_bw() +                      ggplot2::theme(text = ggplot2::element_text(size = plot_font_size),                                     axis.text = ggplot2::element_text(color = \"black\"),                                     legend.position = 'bottom') )"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"suggestions-for-setting-parameters","dir":"Articles","previous_headings":"Introduction","what":"Suggestions for setting parameters","title":"Tutorial: Running the pipeline","text":"example gating 1 FCS sample.","code":""},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Tutorial: Running the pipeline","text":"Optional: include samp_metadata saving properties FCS file processing steps (e.g., compensation matrix, number cells root population)","code":"# Optional to save the samp_metadata   samp_metadata = list()"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"import-fcs","dir":"Articles","previous_headings":"Example","what":"Import FCS","title":"Tutorial: Running the pipeline","text":"","code":"# 2023-06-19 Test if we can pass in a gating set and return a gs # First check that we can return a gs? Yes it worked   ### Read in file   dtTemplate = data.table::fread(gtFile)      ### Load   gt_tcell = openCyto::gatingTemplate(gtFile) #> expanding pop: -/++/- #> Adding population:fsc_ssc_qc #> Adding population:nonDebris #> Adding population:singlets #> Adding population:cd14-cd19- #> Adding population:live #> Adding population:cd3 #> Adding population:cd4+ #> Adding population:cd8+ #> Adding population:cd4+cd8+ #> Adding population:cd4-cd8+ #> Adding population:cd4+cd8- #> Adding population:cd4-cd8-      cs  <- flowWorkspace::load_cytoset_from_fcs(path_fcs)      ### **Optional** -    ## For consistency among different naming conventions for the live/dead   ## change \"Viability\" or \"L/D\" \"LD\" or \"live\" to = \"L_D\" for consistency on gtemplates etc   {if(any(c(\"Viability\", \"L/D\", \"L_D\", \"live\", \"Live\") %in% flowWorkspace::markernames(cs))){          aux_log = flowWorkspace::markernames(cs) == \"Viability\" | flowWorkspace::markernames(cs) == \"L/D\" | flowWorkspace::markernames(cs) == \"L_D\"          flowWorkspace::markernames(cs) = replace(markernames(cs), aux_log, \"LD\")}   }      ## Create a GatingSet of 1 sample   gs = flowWorkspace::GatingSet(cs)      ## Check- how many cells is in the FCS file?    n_root = flowWorkspace::gh_pop_get_count(gs, \"root\")      n_root #> [1] 668160      # Add n_root to samp_metadata   samp_metadata$n_root = n_root"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"compensation","dir":"Articles","previous_headings":"Example","what":"Compensation","title":"Tutorial: Running the pipeline","text":"","code":"# Check no comp applied   chk_cm = flowWorkspace::gh_get_compensations(gs)      chk_cm #> NULL    # Apply comp    gs = getCompGS(gs, path_comp_mat = path_comp_mat)      # Can check that the comp was applied   chk_cm = flowWorkspace::gh_get_compensations(gs)      head(chk_cm@spillover) #>                 AF700-A       APC-A   APC-f750-A      BB515-A    BB660-A #> AF700-A     1.00000e+00 2.48301e-02  2.49284e-01  0.009679220 0.00268438 #> APC-A       1.32334e-01 1.00000e+00  3.37338e-02 -0.000160633 0.01598550 #> APC-f750-A  8.68539e-02 1.38732e-01  1.00000e+00 -0.001767070 0.00222729 #> BB515-A    -1.15670e-06 8.78380e-06 -3.46330e-06  1.000000000 0.00737752 #> BB660-A     8.87227e-02 5.93124e-01  2.00381e-02  0.014618200 1.00000000 #> BB700-A     1.56721e-01 1.03493e-01  5.16101e-02  0.021794700 0.23758800 #>               BB700-A     BB790-A    BUV395-A     BUV496-A     BUV563-A #> AF700-A    0.04732480 0.017307700 0.001813870  1.81722e-03  1.45041e-03 #> APC-A      0.00443383 0.001225970 0.000471851 -5.18352e-05 -3.25396e-05 #> APC-f750-A 0.00135711 0.052727800 0.007016350 -3.55365e-04 -1.00153e-03 #> BB515-A    0.00160540 0.000259797 0.000488654  9.92731e-03  2.45334e-03 #> BB660-A    0.29925900 0.072568700 0.000750601  4.69872e-04  5.91621e-03 #> BB700-A    1.00000000 0.305046000 0.001371840  5.33863e-04  7.68645e-03 #>               BUV615-A    BUV661-A     BUV737-A     BUV805-A      BV421-A #> AF700-A    0.002494550 0.002203370  1.38716e-01  0.033104200  5.11994e-05 #> APC-A      0.001271670 0.114363000  2.21613e-02  0.005274360 -4.09868e-04 #> APC-f750-A 0.000055023 0.013948700  3.17988e-02  0.249248000 -7.88098e-03 #> BB515-A    0.001525590 0.000265054 -1.52650e-06 -0.000011894 -3.13395e-04 #> BB660-A    0.013022400 0.199251000  3.28067e-02  0.008413150 -8.18947e-04 #> BB700-A    0.012374800 0.042845800  1.02680e-01  0.034781800 -1.40587e-03 #>                BV480-A     BV510-A      BV570-A     BV605-A     BV650-A #> AF700-A    0.003390200 2.60901e-03  2.45899e-03 0.003585150 0.004457680 #> APC-A      0.000113668 4.37466e-05  5.85607e-05 0.000850790 0.138441000 #> APC-f750-A 0.003118890 1.52763e-03 -9.31873e-04 0.000173277 0.016350600 #> BB515-A    0.000190708 3.34812e-03  8.84301e-04 0.000579157 0.000126033 #> BB660-A    0.000388549 2.12014e-03  2.71519e-02 0.049095400 0.692174000 #> BB700-A    0.000586408 3.01256e-03  3.65599e-02 0.059112300 0.173298000 #>                BV711-A      BV750-A      BV786-A         PE-A   PE-CF594-A #> AF700-A    2.12730e-01  8.48399e-02  4.39476e-02  0.006840740  2.92636e-02 #> APC-A      2.85134e-02  9.73321e-03  4.17643e-03  0.000280757  5.41964e-03 #> APC-f750-A 5.86523e-03  6.38759e-02  2.26547e-01 -0.002460560  7.43340e-03 #> BB515-A    8.56130e-06 -1.02317e-05 -1.94972e-05 -0.000126331 -7.83382e-05 #> BB660-A    1.61692e-01  4.23041e-02  2.02054e-02  0.000124760  1.78335e-03 #> BB700-A    5.56872e-01  1.49641e-01  8.27345e-02  0.000280215  7.49651e-04 #>                PE-Cy5-A   PE-Cy5.5-A     PE-Cy7-A #> AF700-A     1.64829e-02  3.26051e-01  1.03233e-01 #> APC-A       2.67747e-01  8.10869e-02  2.15633e-02 #> APC-f750-A  4.93700e-02  2.25955e-02  6.09145e-01 #> BB515-A    -6.68526e-05 -3.01727e-05 -1.21999e-05 #> BB660-A     7.25687e-02  2.16664e-02  5.19117e-03 #> BB700-A     2.13325e-02  6.47322e-02  1.92574e-02      ## Optional- save the comp mat matrix   # Can grab with the @spillover from the compensation object   samp_metadata$comp_mat =     chk_cm@spillover"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"transformation","dir":"Articles","previous_headings":"Example","what":"Transformation","title":"Tutorial: Running the pipeline","text":"transformation applied channels : biexponential extra negative decades = 0.5, positive decades = 4.5 width basis = -30 structure table parameters (.csv format) first column flurochrome names corresponding panel, followed parameters. Currently, package supports biexponetial transformation channels getBiexpTransformGS() function. However, user may choose create transformation list explicitly transformations (e.g., archsin) desired. Note {flowWorkspace} package also allows automated transformation calculation “guessing” appropriate parameters. chose explicitly specify biexponential transformation fixed parameters channels match manual gating strategy direct comparison {staRgate} manual gating results.","code":"tbl_biexp_params =      utils::read.csv(path_biexp_params) %>%      janitor::clean_names(case = \"all_caps\")      ## Optional-- saving out the table of parameters as format that's easier to read   # Below there is an option to save it out as the transformerList which is what    # getBiexpTransformGS.R relies on to supply to flowWorkspace::transform   samp_metadata$biexp_params =      tbl_biexp_params    # The biexp table   tbl_biexp_params %>%      gt::gt() ## Optional-- to check what pre-transformed data against post   # Check no transformation before   chk_tf = flowWorkspace::gh_get_transformations(gs)      chk_tf #> list()      dat_pre_transform =      gs %>%      flowWorkspace::gh_pop_get_data() %>%      flowCore::exprs()         # Apply biexp trans   gs = getBiexpTransformGS(gs, path_biexp_params = path_biexp_params)       ## Optional-- to check what pre-transformed data against post   # Check no transformation before   chk_tf = flowWorkspace::gh_get_transformations(gs)      # This is how 1 transformation specification looks like   chk_tf[[1]] #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x558e5f3d6e48> #> <environment: 0x558e5dbe0400> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30      dat_post_transform =      gs %>%      flowWorkspace::gh_pop_get_data() %>%      flowCore::exprs()        ## Optional-- to check that the transformation worked on all provided channels!   summary(dat_pre_transform) #>      FSC-A            FSC-H            FSC-W            SSC-A          #>  Min.   : -6314   Min.   :  9985   Min.   : 47939   Min.   :  -214.1   #>  1st Qu.: 21001   1st Qu.: 18417   1st Qu.: 99876   1st Qu.: 11818.6   #>  Median : 96885   Median : 63825   Median :152977   Median : 26766.0   #>  Mean   : 95094   Mean   : 62792   Mean   :151884   Mean   : 31569.6   #>  3rd Qu.:137225   3rd Qu.: 90592   3rd Qu.:186531   3rd Qu.: 40310.7   #>  Max.   :262144   Max.   :262144   Max.   :262144   Max.   :262144.0   #>      SSC-H               SSC-W             BUV395-A            BUV496-A         #>  Min.   :     1.39   Min.   :   172.2   Min.   :-34872.92   Min.   :-22542.62   #>  1st Qu.: 11000.14   1st Qu.: 70259.9   1st Qu.:   -33.67   1st Qu.:   -59.33   #>  Median : 24346.24   Median : 86070.6   Median :   933.36   Median :    74.88   #>  Mean   : 26590.00   Mean   : 91778.5   Mean   :  6815.62   Mean   :   509.23   #>  3rd Qu.: 35189.72   3rd Qu.:100493.4   3rd Qu.: 11405.31   3rd Qu.:  1019.78   #>  Max.   :262144.00   Max.   :262144.0   Max.   :261783.22   Max.   :201715.22   #>     BUV563-A            BUV615-A            BUV661-A         #>  Min.   :-48740.64   Min.   :-56472.09   Min.   :-69593.35   #>  1st Qu.:   -59.49   1st Qu.:   -27.32   1st Qu.:  -118.74   #>  Median :    30.21   Median :    94.02   Median :   -41.35   #>  Mean   :   128.71   Mean   :   304.26   Mean   :   103.85   #>  3rd Qu.:   164.70   3rd Qu.:   301.98   3rd Qu.:    60.31   #>  Max.   :196705.91   Max.   :166154.64   Max.   :190846.42   #>     BUV737-A            BUV805-A            BV421-A          #>  Min.   :-81242.59   Min.   :-42440.89   Min.   :-74121.53   #>  1st Qu.:   -20.26   1st Qu.:   -67.45   1st Qu.:   -10.11   #>  Median :    81.19   Median :    -8.09   Median :   112.50   #>  Mean   :   862.36   Mean   :   623.44   Mean   :  1354.63   #>  3rd Qu.:  1764.78   3rd Qu.:   136.90   3rd Qu.:   456.16   #>  Max.   :209543.39   Max.   :155287.28   Max.   :276974.59   #>     BV480-A             BV510-A             BV570-A          #>  Min.   : -4558.46   Min.   :-90036.41   Min.   :-87927.15   #>  1st Qu.:   -51.29   1st Qu.:    -9.86   1st Qu.:   -37.45   #>  Median :    65.86   Median :    83.58   Median :    80.88   #>  Mean   :   651.21   Mean   :   193.43   Mean   :   645.39   #>  3rd Qu.:   226.56   3rd Qu.:   198.16   3rd Qu.:   247.63   #>  Max.   :242982.33   Max.   :208532.67   Max.   :290973.47   #>     BV605-A             BV650-A             BV711-A          #>  Min.   :-73443.52   Min.   :-42149.14   Min.   :-42113.09   #>  1st Qu.:   -23.58   1st Qu.:   -12.78   1st Qu.:   -48.53   #>  Median :   168.86   Median :   164.26   Median :    30.97   #>  Mean   :   470.18   Mean   :  1642.46   Mean   :  2223.48   #>  3rd Qu.:   419.96   3rd Qu.:  2945.20   3rd Qu.:   232.18   #>  Max.   :279813.50   Max.   :299647.47   Max.   :244522.70   #>     BV750-A             BV786-A             BB515-A          #>  Min.   :-23767.65   Min.   :-77539.53   Min.   :-16044.04   #>  1st Qu.:   -86.12   1st Qu.:   -58.74   1st Qu.:   -10.48   #>  Median :    16.72   Median :    21.91   Median :   106.26   #>  Mean   :  1156.63   Mean   :   384.72   Mean   :   251.77   #>  3rd Qu.:  2226.10   3rd Qu.:   758.10   3rd Qu.:   242.25   #>  Max.   :251123.52   Max.   :247622.31   Max.   :261939.98   #>     BB660-A              BB700-A              BB790-A           #>  Min.   :-144289.20   Min.   :-211882.23   Min.   :-175160.50   #>  1st Qu.:      7.63   1st Qu.:    -52.25   1st Qu.:    -19.68   #>  Median :     99.67   Median :     51.56   Median :    138.82   #>  Mean   :    142.14   Mean   :    196.19   Mean   :    890.25   #>  3rd Qu.:    232.84   3rd Qu.:    376.20   3rd Qu.:   1118.39   #>  Max.   : 143173.88   Max.   : 111347.20   Max.   : 253441.08   #>       PE-A              PE-CF594-A            PE-Cy5-A         #>  Min.   :-164795.72   Min.   :-156548.30   Min.   :-44865.78   #>  1st Qu.:    -74.54   1st Qu.:    -62.89   1st Qu.:   -54.71   #>  Median :     81.67   Median :     68.58   Median :    14.32   #>  Mean   :    367.91   Mean   :    687.51   Mean   :   119.59   #>  3rd Qu.:    306.00   3rd Qu.:    347.38   3rd Qu.:    99.77   #>  Max.   :  82092.15   Max.   : 214774.12   Max.   :216664.38   #>    PE-Cy5.5-A           PE-Cy7-A             APC-A            #>  Min.   :-62631.06   Min.   :-71222.91   Min.   :-161681.08   #>  1st Qu.:     6.27   1st Qu.:   -36.62   1st Qu.:    -28.11   #>  Median :   121.66   Median :    -2.71   Median :     79.44   #>  Mean   :   232.12   Mean   :    97.01   Mean   :    908.14   #>  3rd Qu.:   283.19   3rd Qu.:    35.18   3rd Qu.:    446.16   #>  Max.   :213395.53   Max.   :240019.05   Max.   : 277940.47   #>     AF700-A            APC-f750-A             Time          #>  Min.   :-40922.90   Min.   :-15654.48   Min.   :   3.812   #>  1st Qu.:   -89.22   1st Qu.:   -51.97   1st Qu.:1201.521   #>  Median :   -49.92   Median :    -0.70   Median :2393.280   #>  Mean   :    81.18   Mean   :    95.98   Mean   :2391.773   #>  3rd Qu.:    -2.59   3rd Qu.:    90.11   3rd Qu.:3580.679   #>  Max.   :254940.75   Max.   :201944.88   Max.   :4774.103   summary(dat_post_transform) #>      FSC-A            FSC-H            FSC-W            SSC-A          #>  Min.   : -6314   Min.   :  9985   Min.   : 47939   Min.   :  -214.1   #>  1st Qu.: 21001   1st Qu.: 18417   1st Qu.: 99876   1st Qu.: 11818.6   #>  Median : 96885   Median : 63825   Median :152977   Median : 26766.0   #>  Mean   : 95094   Mean   : 62792   Mean   :151884   Mean   : 31569.6   #>  3rd Qu.:137225   3rd Qu.: 90592   3rd Qu.:186531   3rd Qu.: 40310.7   #>  Max.   :262144   Max.   :262144   Max.   :262144   Max.   :262144.0   #>      SSC-H               SSC-W             BUV395-A           BUV496-A       #>  Min.   :     1.39   Min.   :   172.2   Min.   :-14451.1   Min.   :-9192.3   #>  1st Qu.: 11000.14   1st Qu.: 70259.9   1st Qu.:   948.2   1st Qu.:  898.6   #>  Median : 24346.24   Median : 86070.6   Median :  2003.2   Median : 1159.1   #>  Mean   : 26590.00   Mean   : 91778.5   Mean   :  1973.7   Mean   : 1407.4   #>  3rd Qu.: 35189.72   3rd Qu.:100493.4   3rd Qu.:  2972.4   3rd Qu.: 2040.6   #>  Max.   :262144.00   Max.   :262144.0   Max.   :  4096.0   Max.   : 4003.2   #>     BUV563-A           BUV615-A           BUV661-A           BUV737-A        #>  Min.   :-20365.7   Min.   :-23663.2   Min.   :-29259.4   Min.   :-34227.8   #>  1st Qu.:   898.3   1st Qu.:   960.6   1st Qu.:   787.5   1st Qu.:   974.3   #>  Median :  1073.1   Median :  1195.1   Median :   933.3   Median :  1171.0   #>  Mean   :  1139.2   Mean   :  1278.3   Mean   :  1030.2   Mean   :  1527.5   #>  3rd Qu.:  1321.1   3rd Qu.:  1525.5   3rd Qu.:  1131.3   3rd Qu.:  2265.8   #>  Max.   :  3994.2   Max.   :  3934.1   Max.   :  3983.5   Max.   :  4016.8   #>     BUV805-A           BV421-A            BV480-A         BV510-A         #>  Min.   :-17678.9   Min.   :-31190.6   Min.   :-1522   Min.   :-37978.3   #>  1st Qu.:   883.0   1st Qu.:   994.2   1st Qu.:  914   1st Qu.:   994.7   #>  Median :   998.2   Median :  1229.2   Median : 1142   Median :  1175.6   #>  Mean   :  1207.6   Mean   :  1444.4   Mean   : 1263   Mean   :  1209.5   #>  3rd Qu.:  1273.0   3rd Qu.:  1695.2   3rd Qu.: 1420   3rd Qu.:  1376.1   #>  Max.   :  3910.0   Max.   :  4116.7   Max.   : 4069   Max.   :  4015.0   #>     BV570-A            BV605-A            BV650-A          BV711-A         #>  Min.   :-37078.7   Min.   :-30901.5   Min.   :-17554   Min.   :-17539.1   #>  1st Qu.:   940.8   1st Qu.:   967.8   1st Qu.:   989   1st Qu.:   919.4   #>  Median :  1170.5   Median :  1328.1   Median :  1320   Median :  1074.6   #>  Mean   :  1299.6   Mean   :  1342.3   Mean   :  1627   Mean   :  1363.9   #>  3rd Qu.:  1451.2   3rd Qu.:  1660.1   3rd Qu.:  2467   3rd Qu.:  1428.6   #>  Max.   :  4135.8   Max.   :  4120.6   Max.   :  4148   Max.   :  4071.7   #>     BV750-A           BV786-A            BB515-A           BB660-A       #>  Min.   :-9714.8   Min.   :-32648.4   Min.   :-6420.7   Min.   :-61117   #>  1st Qu.:  847.7   1st Qu.:   899.7   1st Qu.:  993.5   1st Qu.:  1029   #>  Median : 1046.7   Median :  1056.9   Median : 1217.8   Median :  1206   #>  Mean   : 1525.8   Mean   :  1338.2   Mean   : 1262.5   Mean   :  1238   #>  3rd Qu.: 2358.0   3rd Qu.:  1914.4   3rd Qu.: 1443.4   3rd Qu.:  1430   #>  Max.   : 4081.2   Max.   :  4076.2   Max.   : 4096.2   Max.   :  3881   #>     BB700-A            BB790-A              PE-A            PE-CF594-A       #>  Min.   :-89945.4   Min.   :-74283.6   Min.   :-69863.1   Min.   :-66345.6   #>  1st Qu.:   912.2   1st Qu.:   975.5   1st Qu.:   869.5   1st Qu.:   891.7   #>  Median :  1114.5   Median :  1276.4   Median :  1172.0   Median :  1147.1   #>  Mean   :  1248.7   Mean   :  1516.8   Mean   :  1248.4   Mean   :  1323.1   #>  3rd Qu.:  1614.0   3rd Qu.:  2079.3   3rd Qu.:  1530.7   3rd Qu.:  1581.3   #>  Max.   :  3791.4   Max.   :  4084.5   Max.   :  3682.6   Max.   :  4025.5   #>     PE-Cy5-A          PE-Cy5.5-A        PE-Cy7-A            APC-A        #>  Min.   :-18713.1   Min.   :-26290   Min.   :-29954.4   Min.   :-68535   #>  1st Qu.:   907.4   1st Qu.:  1026   1st Qu.:   942.5   1st Qu.:   959   #>  Median :  1042.0   Median :  1246   Median :  1008.7   Median :  1168   #>  Mean   :  1092.7   Mean   :  1288   Mean   :  1053.6   Mean   :  1413   #>  3rd Qu.:  1205.8   3rd Qu.:  1501   3rd Qu.:  1082.8   3rd Qu.:  1686   #>  Max.   :  4028.7   Max.   :  4023   Max.   :  4065.1   Max.   :  4118   #>     AF700-A           APC-f750-A           Time          #>  Min.   :-17031.5   Min.   :-6254.5   Min.   :   3.812   #>  1st Qu.:   841.9   1st Qu.:  912.7   1st Qu.:1201.521   #>  Median :   916.7   Median : 1012.6   Median :2393.280   #>  Mean   :   989.7   Mean   : 1121.0   Mean   :2391.773   #>  3rd Qu.:  1008.9   3rd Qu.: 1187.8   3rd Qu.:3580.679   #>  Max.   :  4086.6   Max.   : 4003.6   Max.   :4774.103      ## Optional-- save out the transformerList    samp_metadata$transformerList = chk_tf"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"pre-gating","dir":"Articles","previous_headings":"Example","what":"Pre-gating","title":"Tutorial: Running the pipeline","text":"context, pre-gating defined gating root population CD3+, CD4+/CD8+ subsets pass data density gating step. {flowAI} step serves quality control (QC) match first Time gate step typically done manual gating. possible, however, user may choose skip step {flowAI} excludes many cells. first step gating template QC step especially important include user chooses exclude {flowAI} step.","code":"flowAI_yn = FALSE  # Run flowAI if TRUE, run it if(flowAI_yn){      # Check if the dir exists   if(!dir.exists(glue::glue(\"{path_out}/flowAI_results\"))){     dir.create(glue::glue(\"{path_out}/flowAI_results\"))   }    # For sample   test_qc = flowAI::flow_auto_qc(flowWorkspace::gh_pop_get_data(gs),                                  folder_results = here::here(glue::glue(\"{path_out}/flowAI_results\")))    # Convert to a flowSet in order to convert to GatingSet   test_qc =      test_qc %>%      # First convert to a flowSet     flowCore::flowSet()    # Rnemae the sample    sampleNames(test_qc) = pt_samp_nm      # convert the flowFrame obj returned in test_qc to a GatingSet to pass to openCyto   gs_qc =       test_qc %>%      flowWorkspace::GatingSet()       # Remote test which is not needed ? to save memory    rm(test_qc)      # Save data   save_gs(gs_qc,           path = paste0(glue::glue(\"{path_out}/data/GatingSet/{pt_samp_nm}_flowAI_qc_{Sys.Date()}\")))  }else{   # if no need to run flowAI, just set gs_qc as gs from previous transformation step   gs_qc = gs   rm(gs) } # Pre-gating up to CD4/8+ with {openCyto}   ## Set seed using today's date    set.seed(glue::glue({format(Sys.Date(), format = \"%Y%m%d\")}))      openCyto::gt_gating(gt_tcell, gs_qc) #> Gating for 'fsc_ssc_qc' #> done! #> done. #> Gating for 'nonDebris' #> done! #> done. #> Gating for 'singlets' #> done! #> done. #> Gating for 'cd14-cd19-' #> done! #> done. #> Gating for 'live' #> done! #> done. #> Gating for 'cd3' #> done! #> done. #> Gating for 'cd8+' #> done! #> done. #> Gating for 'cd4+' #> done! #> done. #> Population 'cd4-cd8-' #> done. #> Population 'cd4+cd8-' #> done. #> Population 'cd4-cd8+' #> done. #> Population 'cd4+cd8+' #> done. #> finished. ## Check autoplot   ggcyto::autoplot(gs_qc[[1]])"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"extract-intensity-matrix","dir":"Articles","previous_headings":"Example","what":"Extract intensity matrix","title":"Tutorial: Running the pipeline","text":"","code":"# Extract intensity matrix from GatingSet object   ## Grab marker names from GatingSet for labeling col names in intensity matrix   ## Can skip this step if you know the exact namings of the marker names in your FCS files     # In that case, supply a string is fine:      # marker_chnl_names = c(\"CD45RA\", \"CCR7\", \"LAG3\", ...)   marker_chnl_names =      flowWorkspace::gh_pop_get_data(gs_qc) %>%      flowWorkspace::markernames() %>%      as.data.frame() %>%      tibble::rownames_to_column() %>%      dplyr::rename(chnl = rowname,             marker_full = \".\") %>%      # clean up the names      dplyr::mutate(       marker_full = janitor::make_clean_names(marker_full, replace = c(\"-\" = \"\", \"_\" = \"\", \" \" = \"\")) %>% toupper()     ) %>%      # Reorder the marker channel names to start with CD3, CD4, CD8 then the rest     dplyr::arrange(match(marker_full, c(\"CD3\", \"CD4\", \"CD8\"))) %>%      # Clean up     dplyr::mutate(marker_full = ifelse(marker_full == \"FOX_P3\", \"FOXP3\", marker_full))      # For our Tcell panel, we only want to apply the density gating on   # the `markers_to_gate` markers   # Again, this can be made specified explicitly   markers_to_gate =      marker_chnl_names$marker_full %>%     .[!(. %in% c(\"CD3\", \"CD4\", 'CD8', \"LD\", \"CD1419\"))]           ## Grab the intensity matrix from GatingSet   ## the gh_pop_get_indices grabs the 0/1 for whether gated as CD3 intensity_dat =      gs_qc %>%    # 2024-02-05 grab all indices from opencyto gating to be complete?     flowWorkspace::gh_pop_get_indices(y = \"fsc_ssc_qc\") %>%      cbind(gs_qc %>%                 flowWorkspace::gh_pop_get_data() %>%                flowCore::exprs(),           \"fsc_ssc_qc\" = .) %>%      # Add nondebris     cbind(.,            \"nonDebris\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"nonDebris\")) %>%      # singlets     cbind(.,            \"singlets\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"singlets\")) %>%      # cd14-19-     cbind(.,            \"cd14_neg_19_neg\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"cd14-cd19-\")) %>%      # add live     cbind(.,            \"live\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"live\")) %>%      # Add cd3+      cbind(.,            \"cd3_pos\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"cd3\")) %>%      # add on the cd4 and cd8 0/1s     cbind(.,            \"cd4_pos\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"cd4+\")) %>%      cbind(.,            \"cd8_pos\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"cd8+\")) %>%      tibble::as_tibble()  %>%     # Rename with marker names     dplyr::rename(stats::setNames(marker_chnl_names$chnl, as.character(marker_chnl_names$marker_full))) %>%     dplyr::mutate(       cd4_pos_cd8_pos = dplyr::case_when(         cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 1 ~ \"cd4_pos_cd8_pos\",         cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 0 ~ \"cd4_pos_cd8_neg\",         cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 1 ~ \"cd4_neg_cd8_pos\",         cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 0 ~ \"cd4_neg_cd8_neg\"       ),       # Add a subsetting col to do pooled       pooled_col =          dplyr::case_when(cd3_pos == 1 ~ \"cd3_pos\")     )       ## Preview of intensity matrix   head(intensity_dat) #> # A tibble: 6 × 45 #>   `FSC-A` `FSC-H` `FSC-W` `SSC-A` `SSC-H` `SSC-W` CD45RA   CD4  ICOS  CD25  TIM3 #>     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1  14579.  12925.  91156.   6783.   6899.  59440.   886.  899.  878. 1407.  816. #> 2 202125. 124564. 207600.  80855.  72317. 105031.  3117. 1556. 1215. 1037. 1882. #> 3  90722.  63836. 153095.  20125.  19375.  78122.  2790. 2117. 1002. 1400. 1165. #> 4 196356. 138171. 178294.  39164.  36158.  96089.  3103. 1223. 1438. 1412. 1624. #> 5  12172.  12217.  83027.   7823.   7869.  61889.   730.  739.  901.  921.  764. #> 6  22775.  17675. 110298.   9843.   6393.  86950.   722.  806.  898. 1260.  551. #> # ℹ 34 more variables: CD27 <dbl>, CD8 <dbl>, CD57 <dbl>, CXCR5 <dbl>, #> #   LD <dbl>, CD1419 <dbl>, CCR4 <dbl>, CCR7 <dbl>, HLADR <dbl>, CD3 <dbl>, #> #   CD28 <dbl>, PD1 <dbl>, LAG3 <dbl>, CD127 <dbl>, CD38 <dbl>, TIGIT <dbl>, #> #   EOMES <dbl>, CTLA4 <dbl>, FOXP3 <dbl>, GITR <dbl>, TBET <dbl>, KI67 <dbl>, #> #   GZM_B <dbl>, Time <dbl>, fsc_ssc_qc <dbl>, nonDebris <dbl>, singlets <dbl>, #> #   cd14_neg_19_neg <dbl>, live <dbl>, cd3_pos <dbl>, cd4_pos <dbl>, #> #   cd8_pos <dbl>, cd4_pos_cd8_pos <chr>, pooled_col <chr>"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"apply-density-gating","dir":"Articles","previous_headings":"Example","what":"Apply density gating","title":"Tutorial: Running the pipeline","text":"suggested strategy based CD3+, can customized based string corresponding column name supplied subset_col get_density_gates function suggested number bins density estimation 40. illustration purposes, apply density gating markers.","code":"# Density gating parameters peak_r = 10 bin_i = 40  neg_intensity_thres = -1000  # select a few markers to gate example_markers = c(\"LAG3\", \"CCR7\", \"CD45RA\", \"CD28\", \"EOMES\", \"CD38\", \"CD127\")  # Read in positive peak thresholds pos_thres = utils::read.csv(path_pos_peak_thresholds)  # Show the exact output from the get_density_gates() function dens_gates_pre =    intensity_dat %>%    dplyr::filter(cd3_pos %in% c(0, 1)) %>%    getDensityGates(intens_dat = .,                    marker = example_markers,                   subset_col = \"cd3_pos\",                   bin_n = bin_i,                   peak_detect_ratio = peak_r,                   pos_peak_threshold = pos_thres %>% dplyr::select(marker, pos_peak_threshold),                   neg_intensity_threshold = neg_intensity_thres)    dens_gates_pre #> # A tibble: 2 × 8 #>   cd3_pos  LAG3  CCR7 CD45RA  CD28 EOMES  CD38 CD127 #>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1       0 1368. 1494.  1225. 1212. 1548. 1306. 1370. #> 2       1 1667. 1852.  1438. 1825. 1850. 1303. 1509.  # Since we apply density gating on CD3+ cells but # Would like to calculate subpopulations with CD4+ and CD8+ as  # the starting parent population, we need to add corresponding rows dens_gates =    dens_gates_pre %>%    dplyr::filter(cd3_pos == 1) %>%    # Since we    tibble::add_row() %>%    tibble::add_row() %>%    tibble::add_row() %>%    dplyr::mutate(cd4_pos_cd8_pos = c(\"cd4_neg_cd8_neg\", \"cd4_pos_cd8_neg\", \"cd4_neg_cd8_pos\", \"cd4_pos_cd8_pos\")) %>%    tidyr::fill(cd3_pos, dplyr::all_of(example_markers), .direction = \"down\")     # View updated gates with the col for CD4/CD8 dens_gates #> # A tibble: 4 × 9 #>   cd3_pos  LAG3  CCR7 CD45RA  CD28 EOMES  CD38 CD127 cd4_pos_cd8_pos #>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <chr>           #> 1       1 1667. 1852.  1438. 1825. 1850. 1303. 1509. cd4_neg_cd8_neg #> 2       1 1667. 1852.  1438. 1825. 1850. 1303. 1509. cd4_pos_cd8_neg #> 3       1 1667. 1852.  1438. 1825. 1850. 1303. 1509. cd4_neg_cd8_pos #> 4       1 1667. 1852.  1438. 1825. 1850. 1303. 1509. cd4_pos_cd8_pos  # try get indicator col example_intensity_gated =    getGatedDat(intensity_dat,               subset_col = \"cd4_pos_cd8_pos\",                cutoffs = dens_gates)   # Plot the gate for visual  intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(LAG3)) +   geom_vline(data = dens_gates,               aes(xintercept = LAG3),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of LAG3 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") # If by CD4/CD8,  intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(LAG3)) +   geom_vline(data = dens_gates,               aes(xintercept = LAG3),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of LAG3 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +    facet_wrap(~cd4_pos_cd8_pos) # For CCR7 intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(CCR7)) +   geom_vline(data = dens_gates,               aes(xintercept = CCR7),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of CCR7 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") # If by CD4/CD8,  intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(CCR7)) +   geom_vline(data = dens_gates,               aes(xintercept = CCR7),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of CCR7 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +    facet_wrap(~cd4_pos_cd8_pos) # For CD45RA intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(CD45RA)) +   geom_vline(data = dens_gates,               aes(xintercept = CD45RA),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of CD45RA intensity on all CD3+. Gate identifed by {staRgate} in blue.\") # If by CD4/CD8,  intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(CD45RA)) +   geom_vline(data = dens_gates,               aes(xintercept = CD45RA),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of CD45RA intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +    facet_wrap(~cd4_pos_cd8_pos)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"getting-percentage-data","dir":"Articles","previous_headings":"Example","what":"Getting percentage data","title":"Tutorial: Running the pipeline","text":"can derive count percentage cells combinations markers. subpopulations, denominator defined parent population numerator population interest parent population. getPerc function allows user list markers interest numerator denominator example, consider CD4 CD8 subsets largest parent population (denominator) three markers gated using c(\"LAG3\", \"CCR7\", \"CD45RA\"). additional arguments expand_num expand_denom generates different lists subpopulations calculate counts/percentages . Currently, support : Positive/negative marker num_marker Combinations positive/negative marker(s) denom_marker Combinations positive/negative pairs markers num_marker Combinations positive/negative marker(s) denom_marker Positive/negative marker num_marker Combinations positive/negative marker(s) denom_marker combinations positive/negative marker(s) denom_marker one marker num_marker positive/negative Combinations positive/negative pairs markers num_marker Combinations positive/negative marker(s) denom_marker combinations positive/negative marker(s) denom_marker one marker num_marker positive/negative keep_indicators argument provides 0/1 marker considered numerator denominator subpopulation. especially useful merging onto data format. example, matching strings: “CD4+ & CD8- CD3+” different “CD8- & CD4+ CD3+” “CD4+ CD8- CD3+” example expand_num = FALSE expand_denom = FALSE, keep_indicators = TRUE illustrate columns get _POS _POS_D. examples demonstrate scenarios combinations expand_num expand_denom keep_indicators set FALSE remaining examples. example expand_num = TRUE expand_denom = FALSE example expand_num = FALSE expand_denom = TRUE example expand_num = TRUE expand_denom = TRUE","code":"example_perc1 =    example_intensity_gated %>%    # Should only count the CD3+ cells   dplyr::filter(cd3_pos == 1) %>%    getPerc(.,             num_marker = example_markers,             denom_marker = c(\"CD4\", \"CD8\"),             expand_num = FALSE,             expand_denom = FALSE,            keep_indicators = TRUE)  # For display only, group based on the denominators and  # simplify the names to be numerators example_perc1 %>%    tidyr::separate_wider_delim(subpopulation,                                delim = \"_OF_\",                                names = c(\"num\", \"denom\"),                               cols_remove = FALSE) %>%    dplyr::mutate(denom = paste(\"Denom = \", denom)) %>%    dplyr::group_by(denom) %>%   dplyr::select(-subpopulation) %>%    gt::gt() %>%    gt::fmt_number(columns = \"perc\",                   decimals = 1) example_perc2 =    example_intensity_gated %>%      # Should only count the CD3+ cells     dplyr::filter(cd3_pos == 1) %>%      getPerc(.,               num_marker = example_markers,               denom_marker = c(\"CD4\", \"CD8\"),               expand_num = TRUE,               expand_denom = FALSE,              keep_indicators = FALSE)  # For display only, group based on the denominators and  # simplify the names to be numerators example_perc2 %>%    tidyr::separate_wider_delim(subpopulation,                                delim = \"_OF_\",                                names = c(\"num\", \"denom\"),                               cols_remove = FALSE) %>%    dplyr::mutate(denom = paste(\"Denom = \", denom)) %>%    dplyr::group_by(denom) %>%   dplyr::select(-subpopulation) %>%    gt::gt() %>%    gt::fmt_number(columns = \"perc\",                   decimals = 1) example_perc3 =    example_intensity_gated %>%    # Should only count the CD3+ cells   dplyr::filter(cd3_pos == 1) %>%    getPerc(.,             num_marker = example_markers,             denom_marker = c(\"CD4\", \"CD8\"),             expand_num = FALSE,             expand_denom = TRUE,            keep_indicators = FALSE)   # For display only, group based on the denominators and  # simplify the names to be numerators example_perc3 %>%    tidyr::separate_wider_delim(subpopulation,                                delim = \"_OF_\",                                names = c(\"num\", \"denom\"),                               cols_remove = FALSE) %>%    dplyr::mutate(denom = paste(\"Denom = \", denom)) %>%    dplyr::group_by(denom) %>%   dplyr::select(-subpopulation) %>%    gt::gt() %>%    gt::fmt_number(columns = \"perc\",                   decimals = 1) example_perc4 =    example_intensity_gated %>%    # Should only count the CD3+ cells   dplyr::filter(cd3_pos == 1) %>%    getPerc(.,             num_marker = example_markers,             denom_marker = c(\"CD4\", \"CD8\"),             expand_num = TRUE,             expand_denom = TRUE,            keep_indicators = FALSE)    # For display only, group based on the denominators and  # simplify the names to be numerators example_perc4 %>%    tidyr::separate_wider_delim(subpopulation,                                delim = \"_OF_\",                                names = c(\"num\", \"denom\"),                               cols_remove = FALSE) %>%    dplyr::mutate(denom = paste(\"Denom = \", denom)) %>%    dplyr::group_by(denom) %>%   dplyr::select(-subpopulation) %>%    gt::gt() %>%    gt::fmt_number(columns = \"perc\",                   decimals = 1)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"optional-adding-density-gates-back-to-gatingset","dir":"Articles","previous_headings":"Example","what":"Optional: Adding density gates back to GatingSet","title":"Tutorial: Running the pipeline","text":"Let’s add gate LAG3 CD4+ CD8+","code":"# Grab gate as a numeric current_gate =    dens_gates %>%    dplyr::filter(cd4_pos_cd8_pos == \"cd4_neg_cd8_pos\") %>%    dplyr::pull(LAG3)  # Apply using gs_add_gating-method and # We want a boundary gate openCyto::gs_add_gating_method(   gs_qc,    alias = \"lag3_cd8\",    pop = \"+\",    parent = \"cd4-cd8+\",    dims = \"LAG3\",    gating_method = \"boundary\",   gating_args = list(min = current_gate, max = Inf) )  current_gate =    dens_gates %>%    dplyr::filter(cd4_pos_cd8_pos == \"cd4_pos_cd8_neg\") %>%    dplyr::pull(LAG3)  openCyto::gs_add_gating_method(   gs_qc,    alias = \"lag3_cd4\",    pop = \"+\",    parent = \"cd4+cd8-\",    dims = \"LAG3\",    gating_method = \"boundary\",   gating_args = list(min = current_gate, max = Inf) )  ggcyto::autoplot(gs_qc[[1]])"},{"path":"https://leejasme.github.io/staRgate/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jasme Lee. Author, maintainer.","code":""},{"path":"https://leejasme.github.io/staRgate/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lee J (2024). staRgate: Automated gating pipeline flow cytometry analysis characterize lineage, differentiation, functional states T-cells. R package version 0.0.0.9000, https://leejasme.github.io/staRgate/.","code":"@Manual{,   title = {staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells},   author = {Jasme Lee},   year = {2024},   note = {R package version 0.0.0.9000},   url = {https://leejasme.github.io/staRgate/}, }"},{"path":"https://leejasme.github.io/staRgate/index.html","id":"stargate","dir":"","previous_headings":"","what":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"R-based automated gating pipeline flow cytometry data characterize lineage, differentiation, functional states T-cells GitHub stores {staRgate} R package, currently work progress","code":""},{"path":"https://leejasme.github.io/staRgate/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"{staRgate} package relies Biocondcutor R packages. installing {staRgate}, first setup Bioconductor install packages. {flowCore} {flowWorkspace} dependencies {staRgate} package {openCyto} {flowAI} required run functions {staRgate} used full gating pipeline shown Tutorial Please refer Bioconductor full details installation guidelines install staRgate (currently install GitHub):","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(version = \"3.19\")  BiocManager::install(c(\"openCyto\", \"flowAI\", \"flowCore\", \"flowWorkspace\")) devtools::install_github(\"leejasme/staRgate\")"},{"path":"https://leejasme.github.io/staRgate/index.html","id":"tutorial","dir":"","previous_headings":"","what":"Tutorial","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"full example run pipeline webpage","code":""},{"path":"https://leejasme.github.io/staRgate/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"Jasme Lee (leej22@mskcc.org)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/cleanMarkerNames.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean marker naming conventions — cleanMarkerNames","title":"Clean marker naming conventions — cleanMarkerNames","text":"Purpose: cleans column names consistent formatting PERCENT_POS/NEG_OF_POS/NEG match naming count matrix created pipeline","code":""},{"path":"https://leejasme.github.io/staRgate/reference/cleanMarkerNames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean marker naming conventions — cleanMarkerNames","text":"","code":"cleanMarkerNames(dat)"},{"path":"https://leejasme.github.io/staRgate/reference/cleanMarkerNames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean marker naming conventions — cleanMarkerNames","text":"dat dataframe: markers columns samples rows","code":""},{"path":"https://leejasme.github.io/staRgate/reference/cleanMarkerNames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean marker naming conventions — cleanMarkerNames","text":"dataframe updated column names","code":""},{"path":"https://leejasme.github.io/staRgate/reference/cleanMarkerNames.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clean marker naming conventions — cleanMarkerNames","text":"Inputs:","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"csv file path_biexp_params specify channels apply transformation parameters (negative decades, width basis positive decades).","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"","code":"getBiexpTransformGS(gs, path_biexp_params)"},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"gs GatingSet apply Biexponential Transformation path_biexp_params file path .csv file specifies Biexponential Transformation","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"GatingSet Biexponentially Transformed data","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"default negative decades = 0.5, width basis = -30 positive decades = 4.5. Transformation can applied subset channels included GatingSet. example provided extdata/biexp_transf_parameters_x50.csv","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"csv file path_comp_mat specify channels apply compensation . format matrix col row names correspond channel names","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"","code":"getCompGS(gs, path_comp_mat)"},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"gs GatingSet apply Biexponential Transformation path_comp_mat file path .csv file specifies Compensation Matrix","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"GatingSet compensated data","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"example provided extdata/comp_mat_example_fcs.csv","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"Internal function get_density_gates unique value subset_col, estimate derivatives marker (intensity values)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"","code":"getDensityDerivs(   dens,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1600 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"dens density object density marker string marker gate name needs match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak '  default 1600, biexponential scale","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"list dataframe density estimation corresponding 1st-4th derivatives, indicators local peaks, plateau_pre element corresponds unique value subset_col dataframe: rows correspond bins","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":null,"dir":"Reference","previous_headings":"","what":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"unique value subset_col, gate using density estimated derivatives identify cutoff shoulder (.e., point tapering ) peak marker (intensity values)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"","code":"getDensityGates(   intens_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800,   neg_intensity_threshold = -1000 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, openCyto steps) intensity values cols = intensity value per marker, rows = sample marker string marker(s) gate names need match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold either numeric threshold identify positive peak dataframe supplying multiple marker gate Dataframe needs supplied 2 columns named marker pos_peak_threshold rows corresponding marker gate default 1800 (note biexponential scale) neg_intensity_threshold numeric threshold filter \"negatively\" expressed cells density estimation avoid -compression difficulty distinguishing peaks gates applied filter density estimation, cells < neg_intensity_threshold`` retained intensity matrix steps Expects neg_intensity_thresholdis scale transformed data inintens_datDefault isNULL`: filters applied density estimation based cells corresponding subsets. Suggested biexp. transformed data -1000 corresponds ~-3300 original intensity scale)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"tibble gates/cutoffs marker unique subset found subset_col rows correspond unique values subset_col, cols correspond marker","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"Internal function getDensityGates unique value subset_col, matrix storing calculations density gating contains: first fourth derivatives density, indicators local peaks, \"real peaks\", plateau_pre cutoff","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"","code":"getDensityMats(   intens_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, gated CD4/CD8) intensity values cols = intensity value per marker, rows = sample marker string marker gate name needs match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak '  default 1800, biexponential scale","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"tibble matrices marker containing calculations density gating unique subset found subset_col rows correspond unique values subset_col, cols correspond ?","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Determine the ","title":"Internal function: Determine the ","text":"Internal function getDensityGates","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Determine the ","text":"","code":"getDensityPeakCutoff(   dens_binned_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1600,   dens_flip = FALSE )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Determine the ","text":"dens_binned_dat list dataframe output getDensityDerivs marker string marker gate name needs match exactly column name dens_binned_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak default 1600, biexponential scale dens_flip logical whether gating applied \"backwards\" peak positive peak want gate left peak instead right","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Determine the ","text":"list dataframe dens_binned_dat additional columns added peak(s) identified cutoff element corresponds unique value subset_col dataframe: rows correspond bins","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"Adds indicator column (0/1) intens_dat marker cutoffs indicated columns cutoffs","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"","code":"getGatedDat(intens_dat = intensity_dat, cutoffs, subset_col)"},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, openCyto steps) intensity values rows = sample cutoffs tibble gates/cutoffs markers gate Expects cutoffs match format output getDensityGates() column corresponding marker, rows subsets defined subset_col subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"intens_dat additional cols attached marker cutoffs","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"naming convention tagged indicator columns tolower(<marker_name>_pos) 0 indicates negativity intensity < gate provided 1 indicates positivity intensity > gate provided","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getMarkerIndicators.html","id":null,"dir":"Reference","previous_headings":"","what":"Get indicators of marker positive/negative in numerator and denominator for cell subpopulations — getMarkerIndicators","title":"Get indicators of marker positive/negative in numerator and denominator for cell subpopulations — getMarkerIndicators","text":"Useful matching subpopulation names ignoring order naming markers","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getMarkerIndicators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get indicators of marker positive/negative in numerator and denominator for cell subpopulations — getMarkerIndicators","text":"","code":"getMarkerIndicators(dat, col_nm = \"marker\", markers_nm)"},{"path":"https://leejasme.github.io/staRgate/reference/getMarkerIndicators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get indicators of marker positive/negative in numerator and denominator for cell subpopulations — getMarkerIndicators","text":"dat dataframe add indicators expects rows correspond subpopulation col_nm string indicating column dat (.e., dat$col_nm) find subpopulation names apply indicators Default 'marker' Expectation naming convention markers_nm string vector names markers generate indicators default currently","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getMarkerIndicators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get indicators of marker positive/negative in numerator and denominator for cell subpopulations — getMarkerIndicators","text":"dataframe dat returned additional columns indicators positivity value markers_nm 2 columns indicate positivity numerator denominator Naming conventions tolower(marker_name)_pos positivity indicator numerator tolower(marker_name)_pos_d positivity denominator","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getMarkerIndicators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get indicators of marker positive/negative in numerator and denominator for cell subpopulations — getMarkerIndicators","text":"Inputs:","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the percentage of positive cells for specific subpopulations — getPerc","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"Expects data input output get_gated_dat indicator columns specific naming convention (see ).","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"","code":"getPerc(   intens_dat,   num_marker,   denom_marker,   expand_num = FALSE,   expand_denom = FALSE,   keep_indicators = TRUE )"},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"intens_dat dataframe gated data indicator columns per marker interest (specify num_marker denom_marker) naming convention marker_pos per marker values 0 indicate negative-, 1 indicate positive-expressing num_marker string marker(s) specify numerator subpopulations interest See expand_num argument examples specify denom_marker string marker(s) specify denominator subpopulations interest See expand_denom argument examples specify. expand_num logical, accepts TRUE FALSE default FALSE expand_num = TRUE, currently considers pairs markers specified num_marker numerator subpopulation calculations (e.g., CD4+ & CD8- CD3+) expand_num = FALSE, considers marker specified num_marker individually numerator subpopulation calculations (e.g., CD4+ CD3+) expand_denom logical, accepts TRUE FALSE default FALSE expand_denom = TRUE, currently considers 1 marker num_marker unique combinations denom_marker generate list subpopulations e.g., denom_marker = c(\"CD8\"), num_marker = c(\"LAG3\", \"KI67\"), expand_denom = TRUE, subpopulations include: 1. LAG3+ CD8+, LAG3- CD8+, LAG3+ CD8-, LAG3- CD8-, 2. KI67+ CD8+, KI67- CD8+, KI67+ CD8-, KI67- CD8-, 3. KI67+ (LAG3+ & CD8+), KI67- (LAG3+ & CD8+), KI67+ (LAG3+ & CD8-), KI67- (LAG3+ & CD8-)...etc., 4. LAG3+ (KI67+ & CD8+), LAG3- (KI67+ & CD8+), LAG3+ (KI67+ & CD8-), LAG3- (KI67+ & CD8-)...etc., expand_denom = FALSE, generates list subpopulations based unique combinations denom_marker (e.g., denom_marker = c(\"CD4\") expand_denom = FALSE considers subpopulations denominator CD4+ CD4- whereas denom_marker = c(\"CD4\", \"CD8\" expand_denom = FALSE consider subpopulations denominators (CD4- & CD8-), (CD4+ & CD8-), (CD4- & CD8+) (CD4+ & CD8+)) keep_indicators logical, accepts TRUE FALSE default TRUE keep_indicators = TRUE, return indicator columns 0/1 specify markers considered numerator denominators subpopulations. Naming convention numerator cols <marker>_POS denominator cols <marker>_POS_D. sets columns, 0 indicates considered negative cells, 1 indicates considered positive cells NA_real_ indicates consideration subpopulation. useful matching percentage data potentially different naming conventions avoid exact string matches subpopulation take note order also matters matching strings: \"CD4+ & CD8- CD3+\" different \"CD8- & CD4+ CD3+\"","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"tibble containing percentage cells rows correspond subpopulation specified subpopulation, n_num indicates number cells satisifies numerator conditions, n_denom indicates number cells satisifies denominator conditions, perc = n_num divided n_denom unless n_denom = 0, perc = NA_real_","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"subpopulations defined (num marker(s)) (denom marker(s)) num denotes numerator, denom denotes denominator (shorthands used function arguments)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://leejasme.github.io/staRgate/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://leejasme.github.io/staRgate/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://leejasme.github.io/staRgate/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://leejasme.github.io/staRgate/reference/staRgate-package.html","id":null,"dir":"Reference","previous_headings":"","what":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","title":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","text":"R-based automated gating pipeline flow cytometry data (one paragraph).","code":""},{"path":[]},{"path":"https://leejasme.github.io/staRgate/reference/staRgate-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","text":"Maintainer: Jasme Lee leej22@mskcc.org (ORCID)","code":""}]
