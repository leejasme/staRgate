[{"path":"https://leejasme.github.io/staRgate/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 staRgate authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Tutorial: Running the pipeline","text":"staRgate automated gating pipeline process analyze flow cytometry data characterize lineage, differentiation functional states T-cells. pipeline designed mimic manual gating defining flow biomarker positive populations relative unimodal background population include cells varying intensities marker expression. achieved via estimating kernel density intensity distribution corresponding derivatives. pipeline integrates density gating method conjuction pre-processing steps achieved via R package {openCyto} optional step {flowAI}. flow data stored within R GatingSet object, makes easily transferable flow cytometry workflows available BioConductor. vignette walk run {staRgate} pipeline starting importing flow cytometry standard (FCS) file R preprocessing gating, well identifying T-cell subpopulations downstream analysis. pipeline returns results single-cell level well summarized sample-level data (percentages T-cell cells identifying subpopulations). illustration purposes, example FCS file used vignette stored package data concatenated file limited first 30k events/cells acquired reduce run time file size.","code":""},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Tutorial: Running the pipeline","text":"{staRgate} package relies Biocondcutor R packages. installing {staRgate}, first setup Bioconductor install dependencies. instructions instructions installing Bioconductor install staRgate: essential dependencies running {staRgate} package include: {flowCore}, {flowWorkspace}. following packages needed fully run pipeline shown Tutorial, required {staRgate} code chunks run: {openCyto}, {flowAI}, {ggplot2}, {ggCyto}, {gt}","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  # If running R4.3 BiocManager::install(version = \"3.18\")  # If running R4.4 # BiocManager::install(version = \"3.19\")   BiocManager::install(c(\"openCyto\",                        \"flowAI\",                        \"flowCore\",                        \"flowWorkspace\",                        \"ggcyto\")) devtools::install_github(\"leejasme/staRgate\") # Load libraries library(staRgate) library(openCyto) library(flowWorkspace) #> As part of improvements to flowWorkspace, some behavior of #> GatingSet objects has changed. For details, please read the section #> titled \"The cytoframe and cytoset classes\" in the package vignette: #>  #>   vignette(\"flowWorkspace-Introduction\", \"flowWorkspace\") library(flowCore) # Just for plotting in the vignette library(ggplot2)  # Set up dynamic variables  pt_samp_nm = \"flow_sample_1\"  ## File path to the FCS file path_fcs = system.file(\"extdata\", \"example_fcs.fcs\", package = \"staRgate\", mustWork = TRUE)  ## File path to the compensation matrix csv file ## Expect format to match flowJo exported version path_comp_mat = system.file(\"extdata\", \"comp_mat_example_fcs.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path for outputs/saving # Maybe not the best sol, but create a temp dir? path_out = tempdir() # Print the path_out for user to see path_out #> [1] \"/tmp/Rtmp6CJGBW\"  ## File path Gating template gtFile = system.file(\"extdata\", \"gating_template_x50_tcell.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path to biexp parameters ## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec ## full name should contain the channel/dye name #3 remaining cols fill in with desired parameter values path_biexp_params = system.file(\"extdata\", \"biexp_transf_parameters_x50.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path to positive peak thresholds path_pos_peak_thresholds = system.file(\"extdata\", \"pos_peak_thresholds.csv\", package = \"staRgate\", mustWork = TRUE) # Some preferred ggplot settings.  # Not required/relevant for gating  plot_font_size = 13  ggplot2::theme_set(ggplot2::theme_bw() +                      ggplot2::theme(text = ggplot2::element_text(size = plot_font_size),                                     axis.text = ggplot2::element_text(color = \"black\"),                                     legend.position = 'bottom') )"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"input-files-and-function-parameters","dir":"Articles","previous_headings":"","what":"Input files and function parameters","title":"Tutorial: Running the pipeline","text":"order run pipeline, user must data flow cytometry standard (FCS) format. usually output flowJo. input files expected comma-separated values (csv) files. Please see inst folder package examples formats. Matrix column row names correspond channel names, cell values correspond spillover correction applied. can exported csv flowJo’s options table specifying parameters (negative decades, width basis positive decades) applied listed channels gating template required run pre-gating via {openCyto} package includes gating template tailored gating panel T-cell markers. examples modify gating template, please refer openCyto documentation. things keep mind debugging/iterating gating: saving path name (.e., rerunning code), GatingSet folder flowWorkspace::save_gs() command needs deleted {openCyto} save , otherwise, encounter error related invalid path flowWorkspace::save_gs() function","code":""},{"path":[]},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"example-of-automated-gating","dir":"Articles","previous_headings":"","what":"Example of automated gating","title":"Tutorial: Running the pipeline","text":"example gating 1 FCS sample. Optional: include samp_metadata saving properties FCS file processing steps (e.g., compensation matrix, number cells root population)","code":"# Optional to save the samp_metadata   samp_metadata = list()"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"import-fcs","dir":"Articles","previous_headings":"Example of automated gating","what":"Import FCS","title":"Tutorial: Running the pipeline","text":"","code":"# 2023-06-19 Test if we can pass in a gating set and return a gs # First check that we can return a gs? Yes it worked   ### Read in file   dtTemplate = data.table::fread(gtFile)      ### Load   gt_tcell = openCyto::gatingTemplate(gtFile) #> expanding pop: -/++/- #> Adding population:fsc_ssc_qc #> Adding population:nonDebris #> Adding population:singlets #> Adding population:cd14-cd19- #> Adding population:live #> Adding population:cd3 #> Adding population:cd4+ #> Adding population:cd8+ #> Adding population:cd4+cd8+ #> Adding population:cd4-cd8+ #> Adding population:cd4+cd8- #> Adding population:cd4-cd8-      cs  = flowWorkspace::load_cytoset_from_fcs(path_fcs)      ### **Optional** -    ## For consistency among different naming conventions for the live/dead   ## change \"Viability\" or \"L/D\" \"LD\" or \"live\" to = \"L_D\" for consistency on gtemplates etc   {if(any(c(\"Viability\", \"L/D\", \"L_D\", \"live\", \"Live\") %in% flowWorkspace::markernames(cs))){          aux_log = flowWorkspace::markernames(cs) == \"Viability\" | flowWorkspace::markernames(cs) == \"L/D\" | flowWorkspace::markernames(cs) == \"L_D\"          flowWorkspace::markernames(cs) = replace(markernames(cs), aux_log, \"LD\")}   }      ## Create a GatingSet of 1 sample   gs = flowWorkspace::GatingSet(cs)      ## Check- how many cells is in the FCS file?    n_root = flowWorkspace::gh_pop_get_count(gs, \"root\")      n_root #> [1] 30000      # Add n_root to samp_metadata   samp_metadata$n_root = n_root"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"compensation","dir":"Articles","previous_headings":"Example of automated gating","what":"Compensation","title":"Tutorial: Running the pipeline","text":"","code":"# Check no comp applied   chk_cm = flowWorkspace::gh_get_compensations(gs)      chk_cm #> NULL    # Apply comp    gs = getCompGS(gs, path_comp_mat = path_comp_mat)      # Can check that the comp was applied   chk_cm = flowWorkspace::gh_get_compensations(gs)      # Not aware of an accessor that we can use for this   head(chk_cm@spillover) #>                 AF700-A       APC-A   APC-f750-A      BB515-A    BB660-A #> AF700-A     1.00000e+00 2.48301e-02  2.49284e-01  0.009679220 0.00268438 #> APC-A       1.32334e-01 1.00000e+00  3.37338e-02 -0.000160633 0.01598550 #> APC-f750-A  8.68539e-02 1.38732e-01  1.00000e+00 -0.001767070 0.00222729 #> BB515-A    -1.15670e-06 8.78380e-06 -3.46330e-06  1.000000000 0.00737752 #> BB660-A     8.87227e-02 5.93124e-01  2.00381e-02  0.014618200 1.00000000 #> BB700-A     1.56721e-01 1.03493e-01  5.16101e-02  0.021794700 0.23758800 #>               BB700-A     BB790-A    BUV395-A     BUV496-A     BUV563-A #> AF700-A    0.04732480 0.017307700 0.001813870  1.81722e-03  1.45041e-03 #> APC-A      0.00443383 0.001225970 0.000471851 -5.18352e-05 -3.25396e-05 #> APC-f750-A 0.00135711 0.052727800 0.007016350 -3.55365e-04 -1.00153e-03 #> BB515-A    0.00160540 0.000259797 0.000488654  9.92731e-03  2.45334e-03 #> BB660-A    0.29925900 0.072568700 0.000750601  4.69872e-04  5.91621e-03 #> BB700-A    1.00000000 0.305046000 0.001371840  5.33863e-04  7.68645e-03 #>               BUV615-A    BUV661-A     BUV737-A     BUV805-A      BV421-A #> AF700-A    0.002494550 0.002203370  1.38716e-01  0.033104200  5.11994e-05 #> APC-A      0.001271670 0.114363000  2.21613e-02  0.005274360 -4.09868e-04 #> APC-f750-A 0.000055023 0.013948700  3.17988e-02  0.249248000 -7.88098e-03 #> BB515-A    0.001525590 0.000265054 -1.52650e-06 -0.000011894 -3.13395e-04 #> BB660-A    0.013022400 0.199251000  3.28067e-02  0.008413150 -8.18947e-04 #> BB700-A    0.012374800 0.042845800  1.02680e-01  0.034781800 -1.40587e-03 #>                BV480-A     BV510-A      BV570-A     BV605-A     BV650-A #> AF700-A    0.003390200 2.60901e-03  2.45899e-03 0.003585150 0.004457680 #> APC-A      0.000113668 4.37466e-05  5.85607e-05 0.000850790 0.138441000 #> APC-f750-A 0.003118890 1.52763e-03 -9.31873e-04 0.000173277 0.016350600 #> BB515-A    0.000190708 3.34812e-03  8.84301e-04 0.000579157 0.000126033 #> BB660-A    0.000388549 2.12014e-03  2.71519e-02 0.049095400 0.692174000 #> BB700-A    0.000586408 3.01256e-03  3.65599e-02 0.059112300 0.173298000 #>                BV711-A      BV750-A      BV786-A         PE-A   PE-CF594-A #> AF700-A    2.12730e-01  8.48399e-02  4.39476e-02  0.006840740  2.92636e-02 #> APC-A      2.85134e-02  9.73321e-03  4.17643e-03  0.000280757  5.41964e-03 #> APC-f750-A 5.86523e-03  6.38759e-02  2.26547e-01 -0.002460560  7.43340e-03 #> BB515-A    8.56130e-06 -1.02317e-05 -1.94972e-05 -0.000126331 -7.83382e-05 #> BB660-A    1.61692e-01  4.23041e-02  2.02054e-02  0.000124760  1.78335e-03 #> BB700-A    5.56872e-01  1.49641e-01  8.27345e-02  0.000280215  7.49651e-04 #>                PE-Cy5-A   PE-Cy5.5-A     PE-Cy7-A #> AF700-A     1.64829e-02  3.26051e-01  1.03233e-01 #> APC-A       2.67747e-01  8.10869e-02  2.15633e-02 #> APC-f750-A  4.93700e-02  2.25955e-02  6.09145e-01 #> BB515-A    -6.68526e-05 -3.01727e-05 -1.21999e-05 #> BB660-A     7.25687e-02  2.16664e-02  5.19117e-03 #> BB700-A     2.13325e-02  6.47322e-02  1.92574e-02      ## Optional- save the comp mat matrix   # Can grab with the @spillover from the compensation object   samp_metadata$comp_mat =     chk_cm@spillover"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"transformation","dir":"Articles","previous_headings":"Example of automated gating","what":"Transformation","title":"Tutorial: Running the pipeline","text":"transformation applied channels : biexponential extra negative decades = 0.5, positive decades = 4.5 width basis = -30 structure table parameters (.csv format) first column flurochrome names corresponding panel, followed parameters. Currently, package supports biexponetial transformation channels getBiexpTransformGS() function. However, user may choose create transformation list explicitly transformations (e.g., archsin) desired. Note {flowWorkspace} package also allows automated transformation calculation “guessing” appropriate parameters. chose explicitly specify biexponential transformation fixed parameters channels match manual gating strategy direct comparison {staRgate} manual gating results.","code":"tbl_biexp_params =      utils::read.csv(path_biexp_params) %>%      janitor::clean_names(case = \"all_caps\")      ## Optional-- saving out the table of parameters as format that's easier to read   # Below there is an option to save it out as the transformerList which is what    # getBiexpTransformGS.R relies on to supply to flowWorkspace::transform   samp_metadata$biexp_params =      tbl_biexp_params    # The biexp table   tbl_biexp_params %>%      gt::gt() ## Optional-- to check what pre-transformed data against post   # Check no transformation before   chk_tf = flowWorkspace::gh_get_transformations(gs)      chk_tf #> list()      dat_pre_transform =      gs %>%      flowWorkspace::gh_pop_get_data() %>%      flowCore::exprs()         # Apply biexp trans   gs = getBiexpTransformGS(gs, path_biexp_params = path_biexp_params)       ## Optional-- to check what pre-transformed data against post   # Check no transformation before   chk_tf = flowWorkspace::gh_get_transformations(gs)      # This is how 1 transformation specification looks like   chk_tf[[1]] #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x55ab2b766140> #> <environment: 0x55ab2a58caa8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30      dat_post_transform =      gs %>%      flowWorkspace::gh_pop_get_data() %>%      flowCore::exprs()        ## Optional-- to check that the transformation worked on all provided channels!   summary(dat_pre_transform) #>      FSC-A            FSC-H            FSC-W            SSC-A        #>  Min.   :  1492   Min.   :  9988   Min.   : 54676   Min.   :  1033   #>  1st Qu.: 21138   1st Qu.: 18451   1st Qu.: 99971   1st Qu.: 11850   #>  Median : 97082   Median : 63860   Median :153544   Median : 26879   #>  Mean   : 95408   Mean   : 62836   Mean   :152152   Mean   : 31716   #>  3rd Qu.:137767   3rd Qu.: 90685   3rd Qu.:186615   3rd Qu.: 40599   #>  Max.   :262144   Max.   :262144   Max.   :262144   Max.   :262144   #>      SSC-H            SSC-W           AF700-A              APC-A           #>  Min.   :  1231   Min.   : 21321   Min.   :-40597.32   Min.   :-83668.63   #>  1st Qu.: 11045   1st Qu.: 70248   1st Qu.:   -89.72   1st Qu.:   -27.74   #>  Median : 24490   Median : 86074   Median :   -50.31   Median :    80.28   #>  Mean   : 26669   Mean   : 91965   Mean   :    51.63   Mean   :   893.85   #>  3rd Qu.: 35312   3rd Qu.:100669   3rd Qu.:    -2.40   3rd Qu.:   442.46   #>  Max.   :262144   Max.   :262144   Max.   :117999.96   Max.   :258429.72   #>    APC-f750-A            BB515-A             BB660-A          #>  Min.   :-15427.155   Min.   : -8649.57   Min.   :-81303.97   #>  1st Qu.:   -51.782   1st Qu.:   -11.09   1st Qu.:     8.37   #>  Median :    -0.517   Median :   105.76   Median :   100.04   #>  Mean   :    86.131   Mean   :   234.41   Mean   :   154.55   #>  3rd Qu.:    89.942   3rd Qu.:   244.52   3rd Qu.:   235.17   #>  Max.   : 10246.643   Max.   :133731.45   Max.   :123396.73   #>     BB700-A             BB790-A              BUV395-A         #>  Min.   :-77947.38   Min.   :-171716.41   Min.   :-34770.30   #>  1st Qu.:   -52.99   1st Qu.:    -18.98   1st Qu.:   -32.52   #>  Median :    49.92   Median :    138.56   Median :   960.00   #>  Mean   :   209.92   Mean   :    901.38   Mean   :  6796.03   #>  3rd Qu.:   373.89   3rd Qu.:   1124.65   3rd Qu.: 11336.71   #>  Max.   : 38183.27   Max.   : 196894.52   Max.   :101130.94   #>     BUV496-A            BUV563-A            BUV615-A         #>  Min.   :-21624.89   Min.   : -4940.99   Min.   :  -819.99   #>  1st Qu.:   -59.50   1st Qu.:   -58.47   1st Qu.:   -25.87   #>  Median :    72.92   Median :    29.19   Median :    94.06   #>  Mean   :   508.88   Mean   :   131.69   Mean   :   305.05   #>  3rd Qu.:  1018.48   3rd Qu.:   163.32   3rd Qu.:   299.30   #>  Max.   : 12533.95   Max.   :193698.25   Max.   :163601.52   #>     BUV661-A            BUV737-A            BUV805-A         #>  Min.   :-19976.12   Min.   :-34474.75   Min.   : -2277.25   #>  1st Qu.:  -117.70   1st Qu.:   -20.66   1st Qu.:   -67.60   #>  Median :   -41.57   Median :    81.00   Median :    -7.75   #>  Mean   :    98.23   Mean   :   860.45   Mean   :   615.80   #>  3rd Qu.:    61.91   3rd Qu.:  1764.78   3rd Qu.:   136.72   #>  Max.   :142146.95   Max.   : 98435.47   Max.   :111528.16   #>     BV421-A             BV480-A             BV510-A          #>  Min.   :-34983.16   Min.   : -1604.91   Min.   :-62086.07   #>  1st Qu.:   -10.76   1st Qu.:   -49.19   1st Qu.:   -10.44   #>  Median :   113.66   Median :    67.76   Median :    83.43   #>  Mean   :  1321.77   Mean   :   664.87   Mean   :   193.69   #>  3rd Qu.:   461.01   3rd Qu.:   227.83   3rd Qu.:   197.83   #>  Max.   :233484.27   Max.   :228909.97   Max.   :205399.70   #>     BV570-A             BV605-A             BV650-A          #>  Min.   : -2557.12   Min.   :-15426.25   Min.   : -3029.89   #>  1st Qu.:   -37.91   1st Qu.:   -21.88   1st Qu.:   -13.74   #>  Median :    81.17   Median :   172.21   Median :   161.84   #>  Mean   :   656.24   Mean   :   485.53   Mean   :  1616.83   #>  3rd Qu.:   250.13   3rd Qu.:   424.23   3rd Qu.:  2921.42   #>  Max.   :280203.25   Max.   :221790.52   Max.   :196991.55   #>     BV711-A             BV750-A             BV786-A          #>  Min.   : -3053.64   Min.   :-16241.38   Min.   :-13683.76   #>  1st Qu.:   -48.11   1st Qu.:   -86.54   1st Qu.:   -59.14   #>  Median :    33.28   Median :    15.93   Median :    21.86   #>  Mean   :  2247.52   Mean   :  1152.19   Mean   :   393.86   #>  3rd Qu.:   236.58   3rd Qu.:  2227.86   3rd Qu.:   750.71   #>  Max.   :228820.50   Max.   :141663.83   Max.   :181618.50   #>       PE-A              PE-CF594-A            PE-Cy5-A         #>  Min.   :-158344.33   Min.   :-156548.30   Min.   :-14296.08   #>  1st Qu.:    -74.52   1st Qu.:    -62.45   1st Qu.:   -55.40   #>  Median :     82.19   Median :     67.09   Median :    14.74   #>  Mean   :    367.16   Mean   :    679.63   Mean   :    97.37   #>  3rd Qu.:    302.49   3rd Qu.:    342.16   3rd Qu.:   100.11   #>  Max.   :  25212.26   Max.   :  95713.01   Max.   :207472.58   #>    PE-Cy5.5-A           PE-Cy7-A              Time    #>  Min.   :-24382.69   Min.   :  -489.16   Min.   :48   #>  1st Qu.:     6.11   1st Qu.:   -37.00   1st Qu.:48   #>  Median :   120.63   Median :    -2.74   Median :48   #>  Mean   :   229.33   Mean   :   100.07   Mean   :48   #>  3rd Qu.:   287.22   3rd Qu.:    34.86   3rd Qu.:48   #>  Max.   :170867.83   Max.   :196990.38   Max.   :48   summary(dat_post_transform) #>      FSC-A            FSC-H            FSC-W            SSC-A        #>  Min.   :  1492   Min.   :  9988   Min.   : 54676   Min.   :  1033   #>  1st Qu.: 21138   1st Qu.: 18451   1st Qu.: 99971   1st Qu.: 11850   #>  Median : 97082   Median : 63860   Median :153544   Median : 26879   #>  Mean   : 95408   Mean   : 62836   Mean   :152152   Mean   : 31716   #>  3rd Qu.:137767   3rd Qu.: 90685   3rd Qu.:186615   3rd Qu.: 40599   #>  Max.   :262144   Max.   :262144   Max.   :262144   Max.   :262144   #>      SSC-H            SSC-W           AF700-A             APC-A          #>  Min.   :  1231   Min.   : 21321   Min.   :-16892.6   Min.   :-35262.5   #>  1st Qu.: 11045   1st Qu.: 70248   1st Qu.:   840.9   1st Qu.:   959.7   #>  Median : 24490   Median : 86074   Median :   915.9   Median :  1169.3   #>  Mean   : 26669   Mean   : 91965   Mean   :   990.0   Mean   :  1415.6   #>  3rd Qu.: 35312   3rd Qu.:100669   3rd Qu.:  1009.3   3rd Qu.:  1682.2   #>  Max.   :262144   Max.   :262144   Max.   :  3812.1   Max.   :  4091.4   #>    APC-f750-A         BB515-A           BB660-A          BB700-A         #>  Min.   :-6157.6   Min.   :-3266.9   Min.   :-34254   Min.   :-32822.4   #>  1st Qu.:  913.1   1st Qu.:  992.3   1st Qu.:  1030   1st Qu.:   910.8   #>  Median : 1013.0   Median : 1216.9   Median :  1206   Median :  1111.3   #>  Mean   : 1120.5   Mean   : 1262.0   Mean   :  1245   Mean   :  1252.8   #>  3rd Qu.: 1187.5   3rd Qu.: 1446.7   3rd Qu.:  1433   3rd Qu.:  1611.5   #>  Max.   : 2933.3   Max.   : 3856.7   Max.   :  3828   Max.   :  3408.8   #>     BB790-A            BUV395-A           BUV496-A          BUV563-A       #>  Min.   :-72814.7   Min.   :-14407.4   Min.   :-8800.9   Min.   :-1685.2   #>  1st Qu.:   976.8   1st Qu.:   950.4   1st Qu.:  898.2   1st Qu.:  900.2   #>  Median :  1276.0   Median :  2015.1   Median : 1155.4   Median : 1071.1   #>  Mean   :  1518.0   Mean   :  1975.3   Mean   : 1407.2   Mean   : 1139.9   #>  3rd Qu.:  2081.6   3rd Qu.:  2970.2   3rd Qu.: 2040.1   3rd Qu.: 1318.8   #>  Max.   :  3994.6   Max.   :  3757.0   Max.   : 3006.8   Max.   : 3988.7   #>     BUV615-A          BUV661-A          BUV737-A           BUV805-A      #>  Min.   :  79.94   Min.   :-8097.7   Min.   :-14281.3   Min.   :-549.1   #>  1st Qu.: 963.39   1st Qu.:  789.3   1st Qu.:   973.6   1st Qu.: 882.7   #>  Median :1195.18   Median :  932.8   Median :  1170.7   Median : 998.8   #>  Mean   :1278.48   Mean   : 1032.8   Mean   :  1526.5   Mean   :1204.5   #>  3rd Qu.:1522.04   3rd Qu.: 1134.4   3rd Qu.:  2265.8   3rd Qu.:1272.7   #>  Max.   :3928.57   Max.   : 3878.5   Max.   :  3747.4   Max.   :3792.0   #>     BV421-A            BV480-A          BV510-A            BV570-A       #>  Min.   :-14498.2   Min.   :-262.4   Min.   :-26057.5   Min.   :-668.5   #>  1st Qu.:   992.9   1st Qu.: 918.1   1st Qu.:   993.5   1st Qu.: 939.9   #>  Median :  1231.3   Median :1145.6   Median :  1175.3   Median :1171.0   #>  Mean   :  1445.3   Mean   :1265.6   Mean   :  1209.3   Mean   :1305.1   #>  3rd Qu.:  1699.8   3rd Qu.:1422.0   3rd Qu.:  1375.6   3rd Qu.:1454.8   #>  Max.   :  4055.3   Max.   :4048.2   Max.   :  4009.6   Max.   :4121.1   #>     BV605-A           BV650-A          BV711-A          BV750-A        #>  Min.   :-6157.2   Min.   :-870.1   Min.   :-880.3   Min.   :-6504.8   #>  1st Qu.:  971.2   1st Qu.: 987.1   1st Qu.: 920.2   1st Qu.:  846.9   #>  Median : 1333.7   Median :1316.3   Median :1079.1   Median : 1045.2   #>  Mean   : 1347.4   Mean   :1626.2   Mean   :1371.0   Mean   : 1523.6   #>  3rd Qu.: 1664.4   3rd Qu.:2463.9   3rd Qu.:1435.1   3rd Qu.: 2358.3   #>  Max.   : 4037.0   Max.   :3994.7   Max.   :4048.1   Max.   : 3877.2   #>     BV786-A             PE-A            PE-CF594-A          PE-Cy5-A       #>  Min.   :-5414.0   Min.   :-67111.6   Min.   :-66345.6   Min.   :-5675.2   #>  1st Qu.:  898.9   1st Qu.:   869.6   1st Qu.:   892.6   1st Qu.:  906.1   #>  Median : 1056.8   Median :  1172.9   Median :  1144.3   Median : 1042.9   #>  Mean   : 1338.9   Mean   :  1248.4   Mean   :  1320.0   Mean   : 1091.7   #>  3rd Qu.: 1910.2   3rd Qu.:  1526.2   3rd Qu.:  1575.1   3rd Qu.: 1206.4   #>  Max.   : 3965.8   Max.   :  3259.6   Max.   :  3737.4   Max.   : 4013.2   #>    PE-Cy5.5-A       PE-Cy7-A           Time    #>  Min.   :-9977   Min.   : 302.8   Min.   :48   #>  1st Qu.: 1026   1st Qu.: 941.7   1st Qu.:48   #>  Median : 1244   Median :1008.6   Median :48   #>  Mean   : 1289   Mean   :1053.8   Mean   :48   #>  3rd Qu.: 1506   3rd Qu.:1082.1   3rd Qu.:48   #>  Max.   : 3944   Max.   :3994.7   Max.   :48      ## Optional-- save out the transformerList    samp_metadata$transformerList = chk_tf"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"pre-gating","dir":"Articles","previous_headings":"Example of automated gating","what":"Pre-gating","title":"Tutorial: Running the pipeline","text":"context, pre-gating defined gating root population CD3+, CD4+/CD8+ subsets pass data density gating step. {flowAI} step serves quality control (QC) match first Time gate step typically done manual gating. possible, however, user may choose skip step {flowAI} excludes many cells. first step gating template QC step especially important include user chooses exclude {flowAI} step.","code":"flowAI_yn = FALSE  # Run flowAI if TRUE, run it if(flowAI_yn){      # Check if the dir exists   if(!dir.exists(glue::glue(\"{path_out}/flowAI_results\"))){     dir.create(glue::glue(\"{path_out}/flowAI_results\"))   }    # For sample   test_qc = flowAI::flow_auto_qc(flowWorkspace::gh_pop_get_data(gs),                                  folder_results = here::here(glue::glue(\"{path_out}/flowAI_results\")))    # Convert to a flowSet in order to convert to GatingSet   test_qc =      test_qc %>%      # First convert to a flowSet     flowCore::flowSet()    # Rnemae the sample    sampleNames(test_qc) = pt_samp_nm      # convert the flowFrame obj returned in test_qc to a GatingSet to pass to openCyto   gs_qc =       test_qc %>%      flowWorkspace::GatingSet()       # Remote test which is not needed ? to save memory    rm(test_qc)      # Save data   save_gs(gs_qc,           path = paste0(glue::glue(\"{path_out}/data/GatingSet/{pt_samp_nm}_flowAI_qc_{Sys.Date()}\")))  }else{   # if no need to run flowAI, just set gs_qc as gs from previous transformation step   gs_qc = gs   rm(gs) } # Pre-gating up to CD4/8+ with {openCyto}   ## Set seed using today's date    set.seed(glue::glue({format(Sys.Date(), format = \"%Y%m%d\")}))      openCyto::gt_gating(gt_tcell, gs_qc) #> Gating for 'fsc_ssc_qc' #> done! #> done. #> Gating for 'nonDebris' #> done! #> done. #> Gating for 'singlets' #> done! #> done. #> Gating for 'cd14-cd19-' #> done! #> done. #> Gating for 'live' #> done! #> done. #> Gating for 'cd3' #> done! #> done. #> Gating for 'cd8+' #> done! #> done. #> Gating for 'cd4+' #> done! #> done. #> Population 'cd4-cd8-' #> done. #> Population 'cd4+cd8-' #> done. #> Population 'cd4-cd8+' #> done. #> Population 'cd4+cd8+' #> done. #> finished. ## Check autoplot   ggcyto::autoplot(gs_qc[[1]])"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"extract-intensity-matrix","dir":"Articles","previous_headings":"Example of automated gating","what":"Extract intensity matrix","title":"Tutorial: Running the pipeline","text":"","code":"# Extract intensity matrix from GatingSet object   ## Grab marker names from GatingSet for labeling col names in intensity matrix   ## Can skip this step if you know the exact namings of the marker names in your FCS files     # In that case, supply a string is fine:      # marker_chnl_names = c(\"CD45RA\", \"CCR7\", \"LAG3\", ...)   marker_chnl_names =      flowWorkspace::gh_pop_get_data(gs_qc) %>%      flowWorkspace::markernames() %>%      as.data.frame() %>%      tibble::rownames_to_column() %>%      dplyr::rename(chnl = rowname,             marker_full = \".\") %>%      # clean up the names      dplyr::mutate(       marker_full = janitor::make_clean_names(marker_full, replace = c(\"-\" = \"\", \"_\" = \"\", \" \" = \"\")) %>% toupper()     ) %>%      # Reorder the marker channel names to start with CD3, CD4, CD8 then the rest     dplyr::arrange(match(marker_full, c(\"CD3\", \"CD4\", \"CD8\"))) %>%      # Clean up     dplyr::mutate(marker_full = ifelse(marker_full == \"FOX_P3\", \"FOXP3\", marker_full))      # For our Tcell panel, we only want to apply the density gating on   # the `markers_to_gate` markers   # Again, this can be made specified explicitly   markers_to_gate =      marker_chnl_names$marker_full %>%     .[!(. %in% c(\"CD3\", \"CD4\", 'CD8', \"LD\", \"CD1419\"))]           ## Grab the intensity matrix from GatingSet   ## the gh_pop_get_indices grabs the 0/1 for whether gated as CD3 intensity_dat =      gs_qc %>%    # 2024-02-05 grab all indices from opencyto gating to be complete?     flowWorkspace::gh_pop_get_indices(y = \"fsc_ssc_qc\") %>%      cbind(gs_qc %>%                 flowWorkspace::gh_pop_get_data() %>%                flowCore::exprs(),           \"fsc_ssc_qc\" = .) %>%      # Add nondebris     cbind(.,            \"nonDebris\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"nonDebris\")) %>%      # singlets     cbind(.,            \"singlets\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"singlets\")) %>%      # cd14-19-     cbind(.,            \"cd14_neg_19_neg\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"cd14-cd19-\")) %>%      # add live     cbind(.,            \"live\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"live\")) %>%      # Add cd3+      cbind(.,            \"cd3_pos\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"cd3\")) %>%      # add on the cd4 and cd8 0/1s     cbind(.,            \"cd4_pos\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"cd4+\")) %>%      cbind(.,            \"cd8_pos\" = flowWorkspace::gh_pop_get_indices(gs_qc, y = \"cd8+\")) %>%      tibble::as_tibble()  %>%     # Rename with marker names     dplyr::rename(stats::setNames(marker_chnl_names$chnl, as.character(marker_chnl_names$marker_full))) %>%     dplyr::mutate(       cd4_pos_cd8_pos = dplyr::case_when(         cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 1 ~ \"cd4_pos_cd8_pos\",         cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 0 ~ \"cd4_pos_cd8_neg\",         cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 1 ~ \"cd4_neg_cd8_pos\",         cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 0 ~ \"cd4_neg_cd8_neg\"       ),       # Add a subsetting col to do pooled       pooled_col =          dplyr::case_when(cd3_pos == 1 ~ \"cd3_pos\")     )       ## Preview of intensity matrix   head(intensity_dat) #> # A tibble: 6 × 45 #>   `FSC-A` `FSC-H` `FSC-W` `SSC-A` `SSC-H` `SSC-W`  KI67  TBET GZM_B   PD1  LAG3 #>     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1  14579.  12925.  91156.   6783.   6899.  59440.  898.  995.  949.  922. 1184. #> 2  47535.  36802. 124831.  21010.  20507.  79210.  732. 1178.  775.  914. 1169. #> 3 117789.  81878. 183615.  41468.  38820.  93061.  814. 2613. 1960. 1372. 1330. #> 4 230540.  99239. 192036.  48270.  23680. 129099.  821. 1006. 1156. 1675. 1581. #> 5  65184.  43167. 138985.  25413.  21602.  88339.  654. 1252. 1004. 1069. 1257. #> 6 138285.  96765. 182364.  37571.  34888.  93352.  705. 2678.  984. 1034. 1011. #> # ℹ 34 more variables: CD127 <dbl>, CD38 <dbl>, CD45RA <dbl>, CD4 <dbl>, #> #   ICOS <dbl>, CD25 <dbl>, TIM3 <dbl>, CD27 <dbl>, CD8 <dbl>, CD57 <dbl>, #> #   CXCR5 <dbl>, LD <dbl>, CD1419 <dbl>, CCR4 <dbl>, CCR7 <dbl>, HLADR <dbl>, #> #   CD3 <dbl>, CD28 <dbl>, TIGIT <dbl>, EOMES <dbl>, CTLA4 <dbl>, FOXP3 <dbl>, #> #   GITR <dbl>, Time <dbl>, fsc_ssc_qc <dbl>, nonDebris <dbl>, singlets <dbl>, #> #   cd14_neg_19_neg <dbl>, live <dbl>, cd3_pos <dbl>, cd4_pos <dbl>, #> #   cd8_pos <dbl>, cd4_pos_cd8_pos <chr>, pooled_col <chr>"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"apply-density-gating","dir":"Articles","previous_headings":"Example of automated gating","what":"Apply density gating","title":"Tutorial: Running the pipeline","text":"suggested strategy based CD3+, can customized based string corresponding column name supplied subset_col get_density_gates function suggested number bins density estimation 40. illustration purposes, apply density gating markers.","code":"# Density gating parameters peak_r = 10 bin_i = 40  neg_intensity_thres = -1000  # select a few markers to gate example_markers = c(\"LAG3\", \"CCR7\", \"CD45RA\", \"CD28\", \"EOMES\", \"CD38\", \"CD127\")  # Read in positive peak thresholds pos_thres = utils::read.csv(path_pos_peak_thresholds)  # Show the exact output from the get_density_gates() function dens_gates_pre =    intensity_dat %>%    dplyr::filter(cd3_pos %in% c(0, 1)) %>%    getDensityGates(intens_dat = .,                    marker = example_markers,                   subset_col = \"cd3_pos\",                   bin_n = bin_i,                   peak_detect_ratio = peak_r,                   pos_peak_threshold = pos_thres %>% dplyr::select(marker, pos_peak_threshold),                   neg_intensity_threshold = neg_intensity_thres)    dens_gates_pre #> # A tibble: 2 × 8 #>   cd3_pos  LAG3  CCR7 CD45RA  CD28 EOMES  CD38 CD127 #>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1       0 1328. 1452.  1375. 1279. 1533. 1386. 1370. #> 2       1 1634. 1768.  1486. 1840. 1741. 1276. 1452.  # Since we apply density gating on CD3+ cells but # Would like to calculate subpopulations with CD4+ and CD8+ as  # the starting parent population, we need to add corresponding rows dens_gates =    dens_gates_pre %>%    dplyr::filter(cd3_pos == 1) %>%    # Since we    tibble::add_row() %>%    tibble::add_row() %>%    tibble::add_row() %>%    dplyr::mutate(cd4_pos_cd8_pos = c(\"cd4_neg_cd8_neg\", \"cd4_pos_cd8_neg\", \"cd4_neg_cd8_pos\", \"cd4_pos_cd8_pos\")) %>%    tidyr::fill(cd3_pos, dplyr::all_of(example_markers), .direction = \"down\")     # View updated gates with the col for CD4/CD8 dens_gates #> # A tibble: 4 × 9 #>   cd3_pos  LAG3  CCR7 CD45RA  CD28 EOMES  CD38 CD127 cd4_pos_cd8_pos #>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <chr>           #> 1       1 1634. 1768.  1486. 1840. 1741. 1276. 1452. cd4_neg_cd8_neg #> 2       1 1634. 1768.  1486. 1840. 1741. 1276. 1452. cd4_pos_cd8_neg #> 3       1 1634. 1768.  1486. 1840. 1741. 1276. 1452. cd4_neg_cd8_pos #> 4       1 1634. 1768.  1486. 1840. 1741. 1276. 1452. cd4_pos_cd8_pos  # try get indicator col example_intensity_gated =    getGatedDat(intensity_dat,               subset_col = \"cd4_pos_cd8_pos\",                cutoffs = dens_gates)   # Plot the gate for visual  intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(LAG3)) +   geom_vline(data = dens_gates,               aes(xintercept = LAG3),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of LAG3 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") # If by CD4/CD8,  intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(LAG3)) +   geom_vline(data = dens_gates,               aes(xintercept = LAG3),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of LAG3 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +    facet_wrap(~cd4_pos_cd8_pos) # For CCR7 intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(CCR7)) +   geom_vline(data = dens_gates,               aes(xintercept = CCR7),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of CCR7 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") # If by CD4/CD8,  intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(CCR7)) +   geom_vline(data = dens_gates,               aes(xintercept = CCR7),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of CCR7 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +    facet_wrap(~cd4_pos_cd8_pos) # For CD45RA intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(CD45RA)) +   geom_vline(data = dens_gates,               aes(xintercept = CD45RA),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of CD45RA intensity on all CD3+. Gate identifed by {staRgate} in blue.\") # If by CD4/CD8,  intensity_dat %>%    dplyr::filter(cd3_pos == 1) %>%    # additional step to remove large intensity values only when density gating.    # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>%    ggplot() +    geom_density(aes(CD45RA)) +   geom_vline(data = dens_gates,               aes(xintercept = CD45RA),              color = \"blue\",               linetype = \"dashed\") +    labs(subtitle = \"Distribution of CD45RA intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +    facet_wrap(~cd4_pos_cd8_pos)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"getting-percentage-data","dir":"Articles","previous_headings":"Example of automated gating","what":"Getting percentage data","title":"Tutorial: Running the pipeline","text":"can summarize single-cell level data counts percentages cells combinations markers. subpopulations, denominator defined parent population numerator population interest parent population. ndn_d refers number markers considered denominator nn number markers considered numerator. 29-marker panel, denominator specified CD4 CD8 subsets, nd=2n_d = 2 n=23n = 23 markers interest. getPerc function allows user list markers interest numerator denominator example , consider CD4 CD8 subsets key parent populations interest (denominator) three markers gated using c(\"LAG3\", \"CCR7\", \"CD45RA\") (numerator markers). additional arguments expand_num expand_denom generates different lists subpopulations calculate counts/percentages : expand_num: calculations consider pairs numerator markers included?, expand_denom: calculations consider combinations numerator marker parent populations specified denominator? Currently, support four scenarios listed : Numerator: Positive negative marker specified Denominator: Combinations positive negative markers specified LAG3+/- CD4- & CD8- LAG3+/- CD4+ & CD8- LAG3+/- CD4+ & CD8+ LAG3+/- CD4- & CD8+ least 2 markers must included numerator Denominator: Combinations positive negative marker(s) LAG3+/- CD4+/- KI67+/- CD4+/- LAG3- KI67-  CD4+/- LAG3+ KI67-  CD4+/- LAG3- KI67+  CD4+/- LAG3+ KI67+  CD4+/- least 2 markers must included numerator Denominator: Combinations positive negative marker(s), combinations positive negative marker(s) denominator one marker numerator LAG3+/- CD4+/- KI67+/- CD4+/- LAG3+/- CD4-KI67- LAG3+/- CD4-KI67+ LAG3+/- CD4+KI67- LAG3+/- CD4+KI67+ KI67+/- CD4-LAG3- KI67+/- CD4-LAG3+ KI67+/- CD4+LAG3- KI67+/- CD4+LAG3+ least 3 markers must included numerator Denominator: Combinations positive negative marker(s), combinations positive negative marker(s) denominator one marker numerator LAG3+/- CD4+/- KI67+/- CD4+/- CTLA4+/- CD4+/- LAG3+/- CD4-KI67- LAG3+/- CD4-KI67+ LAG3+/- CD4+KI67- LAG3+/- CD4+KI67+ KI67+/- CD4-LAG3- KI67+/- CD4-LAG3+ KI67+/- CD4+LAG3- KI67+/- CD4+LAG3+ …. LAG3- KI67-  CD4+/- LAG3+ KI67-  CD4+/- LAG3- KI67+  CD4+/- LAG3+ KI67+  CD4+/- … LAG3+ KI67+  CD4+/- & CTLA4+/- … keep_indicators argument provides 0/1 marker considered numerator denominator subpopulation. especially useful merging onto data format. example, matching strings: “CD4+ & CD8- CD3+” different “CD8- & CD4+ CD3+” “CD4+ CD8- CD3+” example expand_num = FALSE expand_denom = FALSE, keep_indicators = TRUE illustrate columns get _POS _POS_D. examples demonstrate scenarios combinations expand_num expand_denom keep_indicators set FALSE remaining examples. example expand_num = TRUE expand_denom = FALSE example expand_num = FALSE expand_denom = TRUE example expand_num = TRUE expand_denom = TRUE","code":"example_perc1 =    example_intensity_gated %>%    # Should only count the CD3+ cells   dplyr::filter(cd3_pos == 1) %>%    getPerc(.,             num_marker = example_markers,             denom_marker = c(\"CD4\", \"CD8\"),             expand_num = FALSE,             expand_denom = FALSE,            keep_indicators = TRUE)  # For display only, group based on the denominators and  # simplify the names to be numerators example_perc1 %>%    tidyr::separate_wider_delim(subpopulation,                                delim = \"_OF_\",                                names = c(\"num\", \"denom\"),                               cols_remove = FALSE) %>%    dplyr::mutate(denom = paste(\"Denom = \", denom)) %>%    dplyr::group_by(denom) %>%   dplyr::select(-subpopulation) %>%    gt::gt() %>%    gt::fmt_number(columns = \"perc\",                   decimals = 1) example_perc2 =    example_intensity_gated %>%      # Should only count the CD3+ cells     dplyr::filter(cd3_pos == 1) %>%      getPerc(.,               num_marker = example_markers,               denom_marker = c(\"CD4\", \"CD8\"),               expand_num = TRUE,               expand_denom = FALSE,              keep_indicators = FALSE)  # For display only, group based on the denominators and  # simplify the names to be numerators example_perc2 %>%    tidyr::separate_wider_delim(subpopulation,                                delim = \"_OF_\",                                names = c(\"num\", \"denom\"),                               cols_remove = FALSE) %>%    dplyr::mutate(denom = paste(\"Denom = \", denom)) %>%    dplyr::group_by(denom) %>%   dplyr::select(-subpopulation) %>%    gt::gt() %>%    gt::fmt_number(columns = \"perc\",                   decimals = 1) example_perc3 =    example_intensity_gated %>%    # Should only count the CD3+ cells   dplyr::filter(cd3_pos == 1) %>%    getPerc(.,             num_marker = example_markers,             denom_marker = c(\"CD4\", \"CD8\"),             expand_num = FALSE,             expand_denom = TRUE,            keep_indicators = FALSE)   # For display only, group based on the denominators and  # simplify the names to be numerators example_perc3 %>%    tidyr::separate_wider_delim(subpopulation,                                delim = \"_OF_\",                                names = c(\"num\", \"denom\"),                               cols_remove = FALSE) %>%    dplyr::mutate(denom = paste(\"Denom = \", denom)) %>%    dplyr::group_by(denom) %>%   dplyr::select(-subpopulation) %>%    gt::gt() %>%    gt::fmt_number(columns = \"perc\",                   decimals = 1) example_perc4 =    example_intensity_gated %>%    # Should only count the CD3+ cells   dplyr::filter(cd3_pos == 1) %>%    getPerc(.,             num_marker = example_markers,             denom_marker = c(\"CD4\", \"CD8\"),             expand_num = TRUE,             expand_denom = TRUE,            keep_indicators = FALSE)    # For display only, group based on the denominators and  # simplify the names to be numerators example_perc4 %>%    tidyr::separate_wider_delim(subpopulation,                                delim = \"_OF_\",                                names = c(\"num\", \"denom\"),                               cols_remove = FALSE) %>%    dplyr::mutate(denom = paste(\"Denom = \", denom)) %>%    dplyr::group_by(denom) %>%   dplyr::select(-subpopulation) %>%    gt::gt() %>%    gt::fmt_number(columns = \"perc\",                   decimals = 1)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"optional-adding-density-gates-back-to-gatingset","dir":"Articles","previous_headings":"Example of automated gating","what":"Optional: Adding density gates back to GatingSet","title":"Tutorial: Running the pipeline","text":"Let’s add gate LAG3 CD4+ CD8+","code":"# Grab gate as a numeric current_gate =    dens_gates %>%    dplyr::filter(cd4_pos_cd8_pos == \"cd4_neg_cd8_pos\") %>%    dplyr::pull(LAG3)  # Apply using gs_add_gating-method and # We want a boundary gate openCyto::gs_add_gating_method(   gs_qc,    alias = \"lag3_cd8\",    pop = \"+\",    parent = \"cd4-cd8+\",    dims = \"LAG3\",    gating_method = \"boundary\",   gating_args = list(min = current_gate, max = Inf) )  current_gate =    dens_gates %>%    dplyr::filter(cd4_pos_cd8_pos == \"cd4_pos_cd8_neg\") %>%    dplyr::pull(LAG3)  openCyto::gs_add_gating_method(   gs_qc,    alias = \"lag3_cd4\",    pop = \"+\",    parent = \"cd4+cd8-\",    dims = \"LAG3\",    gating_method = \"boundary\",   gating_args = list(min = current_gate, max = Inf) )  ggcyto::autoplot(gs_qc[[1]])"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Tutorial: Running the pipeline","text":"","code":"sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.5.1        flowCore_2.16.0      flowWorkspace_4.16.0 #> [4] openCyto_2.16.1      staRgate_0.99.0      #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.5        xfun_0.45           bslib_0.7.0         #>  [4] htmlwidgets_1.6.4   lattice_0.22-6      Biobase_2.64.0      #>  [7] vctrs_0.6.5         tools_4.4.1         generics_0.1.3      #> [10] stats4_4.4.1        parallel_4.4.1      tibble_3.2.1        #> [13] fansi_1.0.6         highr_0.11          pkgconfig_2.0.3     #> [16] data.table_1.15.4   RColorBrewer_1.1-3  desc_1.4.3          #> [19] S4Vectors_0.42.1    gt_0.11.0           graph_1.82.0        #> [22] lifecycle_1.0.4     farver_2.1.2        compiler_4.4.1      #> [25] stringr_1.5.1       textshaping_0.4.0   munsell_0.5.1       #> [28] janitor_2.2.0       snakecase_0.11.1    htmltools_0.5.8.1   #> [31] sass_0.4.9          yaml_2.3.9          hexbin_1.28.3       #> [34] pillar_1.9.0        pkgdown_2.1.0       jquerylib_0.1.4     #> [37] tidyr_1.3.1         cachem_1.1.0        RProtoBufLib_2.16.0 #> [40] commonmark_1.9.1    tidyselect_1.2.1    digest_0.6.36       #> [43] stringi_1.8.4       dplyr_1.1.4         purrr_1.0.2         #> [46] labeling_0.4.3      flowClust_3.42.0    fastmap_1.2.0       #> [49] grid_4.4.1          colorspace_2.1-0    cli_3.6.3           #> [52] magrittr_2.0.3      ncdfFlow_2.50.0     RBGL_1.80.0         #> [55] XML_3.99-0.17       utf8_1.2.4          withr_3.0.0         #> [58] scales_1.3.0        lubridate_1.9.3     timechange_0.3.0    #> [61] rmarkdown_2.27      matrixStats_1.3.0   gridExtra_2.3       #> [64] cytolib_2.16.0      ragg_1.3.2          evaluate_0.24.0     #> [67] knitr_1.48          markdown_1.13       rlang_1.1.4         #> [70] Rcpp_1.0.12         glue_1.7.0          xml2_1.3.6          #> [73] Rgraphviz_2.48.0    BiocGenerics_0.50.0 jsonlite_1.8.8      #> [76] plyr_1.8.9          R6_2.5.1            ggcyto_1.32.0       #> [79] systemfonts_1.1.0   fs_1.6.4            zlibbioc_1.50.0"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Tutorial: Running the pipeline","text":"G. Finak, J. Frelinger, W. Jiang, E. W. Newell, J. Ramey, M. M. Davis, S. . Kalams, S. C. De Rosa R. Gottardo, “OpenCyto: Open Source Infrastructure Scalable, Robust, Reproducible, Automated, End--End Flow Cytometry Data Analysis,” PLoS Computational Biology, vol. 10, p. e1003806, August 2014. G. Finak M. Jiang, “flowWorkspace: Infrastructure representing interacting gated ungated cytometry data sets.,” 2023. G. Finak, W. Jiang R. Gottardo, “CytoML cross-platform cytometry data sharing,” Cytometry Part , vol. 93, pp. -7, 2018. G. Monaco, H. Chen, M. Poidinger, J. Chen, J. P. de Magalhães . Larbi, “flowAI: automatic interactive anomaly discerning tools flow cytometry data,” Bioinformatics, vol. 32, p. 2473–2480, April 2016. P. Van, W. Jiang, R. Gottardo G. Finak, “ggcyto: Next-generation open-source visualization software cytometry,” Bioinformatics, 2018.","code":""},{"path":"https://leejasme.github.io/staRgate/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jasme Lee. Author, maintainer.","code":""},{"path":"https://leejasme.github.io/staRgate/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lee J (2024). staRgate: density-based automated gating pipeline flow cytometry analysis characterize lineage, differentiation, functional states T-cells. https://github.com/leejasme/staRgate.","code":"@Manual{,   title = {staRgate: a density-based automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells},   author = {Jasme Lee},   year = {2024},   url = {https://github.com/leejasme/staRgate}, }"},{"path":"https://leejasme.github.io/staRgate/index.html","id":"stargate","dir":"","previous_headings":"","what":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"density-based automated gating pipeline flow cytometry data characterize lineage, differentiation, functional states T-cells GitHub stores {staRgate} R package.","code":""},{"path":"https://leejasme.github.io/staRgate/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"{staRgate} package relies Biocondcutor R packages. installing {staRgate}, first setup Bioconductor install packages. {flowCore} {flowWorkspace} dependencies {staRgate} package {openCyto}, {flowAI}, {ggcyto} required run functions {staRgate} used full gating pipeline shown Tutorial Please refer Bioconductor full details installation guidelines install staRgate (currently install GitHub):","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  # If using R 4.3 BiocManager::install(version = \"3.18\")  # If using R 4.4 # BiocManager::install(version = \"3.19\")   BiocManager::install(c(\"flowCore\", \"flowWorkspace\"))  # In order to run the vignette, BiocManager::install(c(\"openCyto\", \"flowAI\", \"ggcyto\")) devtools::install_github(\"leejasme/staRgate\")"},{"path":"https://leejasme.github.io/staRgate/index.html","id":"tutorial","dir":"","previous_headings":"","what":"Tutorial","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"full example run pipeline webpage","code":""},{"path":"https://leejasme.github.io/staRgate/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"Jasme Lee (leej22@mskcc.org)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"csv file path_biexp_params specify channels apply transformation parameters (negative decades, width basis positive decades).","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"","code":"getBiexpTransformGS(gs, path_biexp_params)"},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"gs GatingSet apply Biexponential Transformation path_biexp_params file path .csv file specifies Biexponential Transformation","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"GatingSet Biexponentially Transformed data","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"default negative decades = 0.5, width basis = -30 positive decades = 4.5. Transformation can applied subset channels included GatingSet. example table provided extdata/biexp_transf_parameters_x50.csv","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"","code":"# This example does not contain all the pre-processing steps required in # getting the GatingSet (gs) ready for Biexp transformation. # To see the steps that are required to creating the (gs), # please see the vignette for a full tutorial  # To make this a runnable example, read in the FCS file to create gs and # directly apply  # File path to the FCS file path_fcs = system.file(\"extdata\", \"example_fcs.fcs\", package = \"staRgate\", mustWork = TRUE) path_biexp_params = system.file(\"extdata\", \"biexp_transf_parameters_x50.csv\",                                  package=\"staRgate\", mustWork=TRUE)  # Create a cytoset then convert to gs cs = flowWorkspace::load_cytoset_from_fcs(path_fcs) gs = flowWorkspace::GatingSet(cs)  # gs must be a GatingSet object gs = getBiexpTransformGS(gs, path_biexp_params=path_biexp_params)  # To check the transformation parameters applied flowWorkspace::gh_get_transformations(gs) #> $`AF700-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede6ea00> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`APC-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede6cc30> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`APC-f750-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede6abf8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BB515-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede68d80> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BB660-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede672f8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BB700-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede64e60> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BB790-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede668d8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV395-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede640c0> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV496-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede618a8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV563-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede5f090> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV615-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede606a8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV661-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede5c050> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV737-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede5a2b8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV805-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581ede562f0> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV421-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581eddbad08> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV480-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edda44e0> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV510-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edd3dcb8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV570-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edd21888> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV605-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edd0ab20> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV650-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edccca30> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV711-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edcca838> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV750-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edcc8f38> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV786-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edcc6b48> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edcc4bb8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-CF594-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edcc0870> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-Cy5-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edcbe448> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-Cy5.5-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edcc0198> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-Cy7-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x5581f82ca140> #> <environment: 0x5581edcbdb98> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>"},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"csv file path_comp_mat specify channels apply compensation . format matrix col row names correspond channel names","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"","code":"getCompGS(gs, path_comp_mat)"},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"gs GatingSet apply Biexponential Transformation path_comp_mat file path .csv file specifies Compensation Matrix","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"GatingSet compensated data","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"example matrix provided extdata/comp_mat_example_fcs.csv","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"","code":"# This example does not contain all the pre-processing steps required in # getting the GatingSet (gs) ready for compensation step # To see the steps that are required to creating the (gs), # please see the vignette for a full tutorial  # To make this a runnable example, read in the FCS file to create gs and # directly apply  # File path to the FCS file path_fcs = system.file(\"extdata\", \"example_fcs.fcs\", package = \"staRgate\", mustWork = TRUE) path_biexp_params = system.file(\"extdata\", \"biexp_transf_parameters_x50.csv\",                                  package=\"staRgate\", mustWork=TRUE)  # Create a cytoset then convert to gs cs = flowWorkspace::load_cytoset_from_fcs(path_fcs) gs = flowWorkspace::GatingSet(cs)  path_comp_mat = system.file(\"extdata\", \"comp_mat_example_fcs.csv\",                              package=\"staRgate\", mustWork=TRUE)  # gs is a GatingSet object gs = getCompGS(gs, path_comp_mat=path_comp_mat)  # Checks the comp mat was successfully applied flowWorkspace::gh_get_compensations(gs) #> Compensation object 'defaultCompensation': #>                 AF700-A        APC-A   APC-f750-A      BB515-A      BB660-A #> AF700-A     1.00000e+00  2.48301e-02  2.49284e-01  0.009679220  2.68438e-03 #> APC-A       1.32334e-01  1.00000e+00  3.37338e-02 -0.000160633  1.59855e-02 #> APC-f750-A  8.68539e-02  1.38732e-01  1.00000e+00 -0.001767070  2.22729e-03 #> BB515-A    -1.15670e-06  8.78380e-06 -3.46330e-06  1.000000000  7.37752e-03 #> BB660-A     8.87227e-02  5.93124e-01  2.00381e-02  0.014618200  1.00000e+00 #> BB700-A     1.56721e-01  1.03493e-01  5.16101e-02  0.021794700  2.37588e-01 #> BB790-A     7.68727e-03  1.93003e-02  3.49874e-02  0.052883600  7.10995e-02 #> BUV395-A   -3.97306e-05 -9.08601e-05 -4.80121e-05 -0.000354928 -3.02965e-04 #> BUV496-A   -1.70875e-04 -1.56429e-04 -7.28591e-05  0.095776400  1.33785e-03 #> BUV563-A   -3.03929e-05  1.56211e-05 -6.56100e-06  0.001668360  2.42316e-02 #> BUV615-A    1.88377e-03  1.04649e-02  4.46188e-04 -0.000136853  8.65835e-03 #> BUV661-A    7.16728e-02  4.13412e-01  1.59599e-02  0.000211115  1.44842e-02 #> BUV737-A    9.29380e-02  1.71690e-03  4.01840e-02 -0.000194453  1.74362e-04 #> BUV805-A    1.48820e-03  2.44068e-04  2.91305e-02 -0.000338491 -4.23913e-05 #> BV421-A    -4.58681e-05 -3.74460e-05  4.48270e-06 -0.000231336 -1.08696e-04 #> BV480-A    -3.92074e-05 -3.39299e-04 -1.30588e-04  0.074170000  1.02894e-03 #> BV510-A     3.99142e-05  3.73202e-05  9.80330e-06  0.007911250  5.75615e-04 #> BV570-A    -1.95859e-05 -4.32965e-05 -2.69880e-05 -0.000243723  3.05622e-02 #> BV605-A     3.73103e-04  2.83992e-03  5.74537e-05 -0.000398720  2.06667e-02 #> BV650-A     2.49470e-02  1.41986e-01  5.86113e-03 -0.000144804  7.52309e-03 #> BV711-A     1.42797e-01  7.78301e-03  4.29540e-02 -0.000232658  5.99928e-04 #> BV750-A     2.67505e-02 -1.90386e-04  3.20051e-02 -0.000578142 -4.42366e-04 #> BV786-A     5.43321e-03  8.58750e-04  4.07434e-02 -0.000103106 -1.87470e-04 #> PE-A        2.42350e-06  4.56944e-05  1.70525e-05  0.001072310  1.07968e-01 #> PE-CF594-A  1.22079e-04  1.15465e-03  1.97960e-05  0.000422330  1.59573e-01 #> PE-Cy5-A    5.44479e-02  2.99784e-01  1.38827e-02  0.000808311  7.99483e-01 #> PE-Cy5.5-A  5.43460e-02  2.06764e-02  1.80785e-02  0.001296560  9.39576e-02 #> PE-Cy7-A    2.68890e-03  9.69828e-04  2.59495e-02  0.002524130  9.41381e-03 #>                 BB700-A     BB790-A    BUV395-A     BUV496-A     BUV563-A #> AF700-A     4.73248e-02 1.73077e-02 0.001813870  1.81722e-03  1.45041e-03 #> APC-A       4.43383e-03 1.22597e-03 0.000471851 -5.18352e-05 -3.25396e-05 #> APC-f750-A  1.35711e-03 5.27278e-02 0.007016350 -3.55365e-04 -1.00153e-03 #> BB515-A     1.60540e-03 2.59797e-04 0.000488654  9.92731e-03  2.45334e-03 #> BB660-A     2.99259e-01 7.25687e-02 0.000750601  4.69872e-04  5.91621e-03 #> BB700-A     1.00000e+00 3.05046e-01 0.001371840  5.33863e-04  7.68645e-03 #> BB790-A     5.02619e-02 1.00000e+00 0.002098810  2.45469e-03  1.13829e-02 #> BUV395-A   -1.53987e-04 3.18150e-06 1.000000000  5.54187e-02  7.64453e-03 #> BUV496-A   -4.51891e-05 6.25497e-05 0.098747400  1.00000e+00  3.65217e-01 #> BUV563-A    6.00392e-03 1.02481e-03 0.057067000  1.35061e-02  1.00000e+00 #> BUV615-A    2.94497e-03 5.66486e-04 0.014661800  2.36745e-03  1.27502e-01 #> BUV661-A    5.32708e-03 1.11836e-03 0.020613000  4.04929e-03  3.19467e-03 #> BUV737-A    6.05855e-02 5.83387e-02 0.045702600  8.07775e-03  2.91077e-03 #> BUV805-A    6.19200e-06 7.86824e-03 0.152528000  2.55410e-02  8.81890e-03 #> BV421-A    -2.56252e-05 2.24736e-05 0.001380780  2.03413e-02  3.32902e-03 #> BV480-A     1.24956e-04 3.73860e-05 0.003972760  1.50035e-01  5.40699e-02 #> BV510-A     1.83050e-04 6.42423e-05 0.000832350  1.42374e-01  7.81014e-02 #> BV570-A     8.98102e-03 1.67519e-03 0.002127950  2.19612e-03  3.36621e-01 #> BV605-A     6.32870e-03 1.46373e-03 0.001450870  3.21298e-04  1.24272e-01 #> BV650-A     2.49028e-03 4.20274e-04 0.000569780  5.27449e-04  1.52040e-03 #> BV711-A     5.23583e-02 2.12145e-02 0.001247390  1.21889e-03  3.18952e-04 #> BV750-A     1.41867e-02 5.33999e-02 0.002543330  1.71614e-03  8.49586e-04 #> BV786-A     7.40567e-04 3.27007e-02 0.002449540  2.19287e-03  1.40705e-03 #> PE-A        2.49105e-02 4.41402e-03 0.000817685  1.55200e-07  1.43966e-01 #> PE-CF594-A  3.54211e-02 6.29059e-03 0.000360426 -1.55097e-05  1.97198e-02 #> PE-Cy5-A    4.23019e-01 1.00346e-01 0.000627548 -3.54997e-05  1.16335e-03 #> PE-Cy5.5-A  8.58340e-01 2.62780e-01 0.000837972 -6.29106e-05  1.20731e-02 #> PE-Cy7-A    1.58009e-02 7.96257e-01 0.000479509  4.18652e-05  3.30418e-03 #>               BUV615-A    BUV661-A     BUV737-A     BUV805-A      BV421-A #> AF700-A    0.002494550 0.002203370  1.38716e-01  3.31042e-02  5.11994e-05 #> APC-A      0.001271670 0.114363000  2.21613e-02  5.27436e-03 -4.09868e-04 #> APC-f750-A 0.000055023 0.013948700  3.17988e-02  2.49248e-01 -7.88098e-03 #> BB515-A    0.001525590 0.000265054 -1.52650e-06 -1.18940e-05 -3.13395e-04 #> BB660-A    0.013022400 0.199251000  3.28067e-02  8.41315e-03 -8.18947e-04 #> BB700-A    0.012374800 0.042845800  1.02680e-01  3.47818e-02 -1.40587e-03 #> BB790-A    0.016154000 0.014608200  4.38512e-02  2.00196e-01  3.00000e-02 #> BUV395-A   0.004780480 0.001071850  1.18867e-04  1.02188e-04  2.78182e-03 #> BUV496-A   0.268124000 0.062647400  7.57148e-03  2.09299e-03 -5.20714e-04 #> BUV563-A   0.801998000 0.176471000  1.60286e-02  4.16364e-03  1.75302e-04 #> BUV615-A   1.000000000 0.308511000  4.42630e-02  1.07449e-02 -2.39673e-04 #> BUV661-A   0.050497000 1.000000000  1.79399e-01  4.21779e-02 -2.48790e-04 #> BUV737-A   0.006115390 0.007730770  1.00000e+00  3.35491e-01 -6.34979e-04 #> BUV805-A   0.009796310 0.003424230  2.00370e-02  1.00000e+00  7.80230e-04 #> BV421-A    0.002006550 0.000352226 -3.83712e-05 -9.46220e-06  1.00000e+00 #> BV480-A    0.044346200 0.011099600  1.18442e-03  9.03918e-05  3.28934e-02 #> BV510-A    0.058545300 0.013467900  1.60638e-03  4.70613e-04  3.12078e-02 #> BV570-A    0.325082000 0.093851200  1.18768e-02  3.12652e-03  2.94131e-01 #> BV605-A    0.432763000 0.188787000  2.95693e-02  8.92535e-03  6.39988e-02 #> BV650-A    0.063496300 0.379917000  5.09028e-02  1.20807e-02  7.45601e-02 #> BV711-A    0.000281952 0.008343360  3.58429e-01  1.20486e-01  1.75048e-01 #> BV750-A    0.000697057 0.000228257  3.97713e-01  2.31938e-01  1.64162e-01 #> BV786-A    0.001364530 0.001438030  8.33593e-02  4.37018e-01  2.18063e-01 #> PE-A       0.084587700 0.019890000  1.79239e-03  3.72104e-04 -8.61543e-04 #> PE-CF594-A 0.089092500 0.022101900  2.17152e-03  4.54470e-04 -4.12173e-04 #> PE-Cy5-A   0.000960021 0.108923000  2.85432e-02  6.31031e-03 -7.45224e-04 #> PE-Cy5.5-A 0.007263900 0.013356100  5.52763e-02  1.95809e-02 -9.63066e-04 #> PE-Cy7-A   0.002259690 0.001000860  1.43824e-02  7.63386e-02  3.96796e-05 #>                BV480-A     BV510-A      BV570-A     BV605-A      BV650-A #> AF700-A    3.39020e-03 2.60901e-03  2.45899e-03 3.58515e-03  4.45768e-03 #> APC-A      1.13668e-04 4.37466e-05  5.85607e-05 8.50790e-04  1.38441e-01 #> APC-f750-A 3.11889e-03 1.52763e-03 -9.31873e-04 1.73277e-04  1.63506e-02 #> BB515-A    1.90708e-04 3.34812e-03  8.84301e-04 5.79157e-04  1.26033e-04 #> BB660-A    3.88549e-04 2.12014e-03  2.71519e-02 4.90954e-02  6.92174e-01 #> BB700-A    5.86408e-04 3.01256e-03  3.65599e-02 5.91123e-02  1.73298e-01 #> BB790-A    1.37380e-02 4.94921e-03  2.97942e-02 4.35257e-02  4.88238e-02 #> BUV395-A   2.08318e-03 4.76822e-04  1.52133e-04 2.53224e-05 -8.20849e-05 #> BUV496-A   7.39427e-02 1.11638e-01  4.81571e-02 3.82096e-02  1.08770e-02 #> BUV563-A   7.79602e-04 2.83422e-04  3.19227e-02 2.53748e-02  6.98563e-03 #> BUV615-A   3.08100e-04 1.58664e-04  6.17956e-03 5.29439e-02  2.51154e-02 #> BUV661-A   4.93886e-04 1.92803e-04  2.63330e-04 1.72809e-03  8.21198e-02 #> BUV737-A   1.00461e-03 5.70701e-04  1.28647e-04 1.30938e-04  1.68492e-04 #> BUV805-A   2.35894e-03 5.99444e-04  4.38039e-04 2.38396e-04  2.55093e-05 #> BV421-A    2.59112e-01 3.43013e-02  7.07011e-03 5.16549e-03  1.39979e-03 #> BV480-A    1.00000e+00 5.09955e-01  2.08648e-01 1.83489e-01  5.17878e-02 #> BV510-A    5.11981e-01 1.00000e+00  5.85075e-01 4.57877e-01  1.17909e-01 #> BV570-A    7.71052e-02 1.05009e-02  1.00000e+00 9.38126e-01  3.66694e-01 #> BV605-A    1.67879e-02 2.43152e-03  2.71032e-01 1.00000e+00  5.59945e-01 #> BV650-A    1.96639e-02 2.67944e-03  4.09261e-03 1.02064e-01  1.00000e+00 #> BV711-A    4.55151e-02 6.38200e-03  1.93257e-03 1.81694e-03  2.58669e-02 #> BV750-A    4.39226e-02 6.76290e-03  3.32289e-03 3.69302e-03  2.25377e-03 #> BV786-A    5.73902e-02 8.97809e-03  4.39112e-03 5.06660e-03  6.18139e-03 #> PE-A       2.07971e-04 1.01976e-04  1.85304e-01 1.11878e-01  3.29431e-02 #> PE-CF594-A 9.85278e-05 3.54644e-05  2.32778e-02 1.02543e-01  3.57088e-02 #> PE-Cy5-A   1.89136e-04 9.74498e-05  1.61336e-03 1.27491e-03  1.77067e-01 #> PE-Cy5.5-A 2.70537e-04 1.59472e-04  1.65944e-02 1.04537e-02  2.36452e-02 #> PE-Cy7-A   2.81302e-04 1.48387e-04  4.82638e-03 3.54159e-03  2.06083e-03 #>                 BV711-A      BV750-A      BV786-A         PE-A   PE-CF594-A #> AF700-A     2.12730e-01  8.48399e-02  4.39476e-02  0.006840740  2.92636e-02 #> APC-A       2.85134e-02  9.73321e-03  4.17643e-03  0.000280757  5.41964e-03 #> APC-f750-A  5.86523e-03  6.38759e-02  2.26547e-01 -0.002460560  7.43340e-03 #> BB515-A     8.56130e-06 -1.02317e-05 -1.94972e-05 -0.000126331 -7.83382e-05 #> BB660-A     1.61692e-01  4.23041e-02  2.02054e-02  0.000124760  1.78335e-03 #> BB700-A     5.56872e-01  1.49641e-01  8.27345e-02  0.000280215  7.49651e-04 #> BB790-A     2.75898e-02  1.57377e-01  3.20000e-01  0.007845450  8.33031e-03 #> BUV395-A   -1.58152e-04  2.35720e-06 -4.73557e-05 -0.000820269 -5.78163e-04 #> BUV496-A    1.77501e-03  1.90057e-04 -3.06013e-04 -0.002193560 -1.56496e-03 #> BUV563-A    1.41310e-03  2.22890e-04  7.99360e-05  0.596597000  3.61606e-01 #> BUV615-A    6.40066e-03  1.53283e-03  6.37276e-04  0.150273000  5.24636e-01 #> BUV661-A    2.12455e-02  5.33407e-03  2.37470e-03  0.000904487  8.15890e-03 #> BUV737-A    2.89365e-02  3.30411e-02  1.64371e-02 -0.000219964  1.09293e-03 #> BUV805-A   -5.49240e-05  1.45854e-03  3.18866e-02  0.000166491  9.85399e-04 #> BV421-A     3.43802e-04  1.06304e-04  6.16866e-05 -0.000634983 -4.00289e-04 #> BV480-A     1.07909e-02  2.23720e-03  7.71069e-04 -0.002727040 -1.37957e-03 #> BV510-A     1.98026e-02  4.38332e-03  2.06777e-03  0.000734193  7.17537e-04 #> BV570-A     7.93858e-02  1.87543e-02  8.92960e-03  0.765370000  5.54055e-01 #> BV605-A     1.29191e-01  3.40905e-02  1.78946e-02  0.254213000  4.53597e-01 #> BV650-A     2.49314e-01  5.54632e-02  2.49019e-02  0.001398340  1.56155e-02 #> BV711-A     1.00000e+00  3.53401e-01  2.29209e-01 -0.000155164 -1.08140e-04 #> BV750-A     2.69688e-01  1.00000e+00  5.20676e-01 -0.001100440 -4.67482e-04 #> BV786-A     2.94720e-02  3.83526e-01  1.00000e+00 -0.000328190  2.38060e-06 #> PE-A        6.48352e-03  1.12158e-03  4.41299e-04  1.000000000  5.14498e-01 #> PE-CF594-A  6.01004e-03  1.32874e-03  5.20298e-04  0.416582000  1.00000e+00 #> PE-Cy5-A    6.54580e-02  1.78464e-02  7.15173e-03  0.039473100  2.31414e-02 #> PE-Cy5.5-A  1.60747e-01  4.01366e-02  2.26926e-02  0.247869000  1.32105e-01 #> PE-Cy7-A    2.53419e-03  3.97731e-02  9.87322e-02  0.102724000  5.67300e-02 #>                PE-Cy5-A   PE-Cy5.5-A     PE-Cy7-A #> AF700-A     1.64829e-02  3.26051e-01  1.03233e-01 #> APC-A       2.67747e-01  8.10869e-02  2.15633e-02 #> APC-f750-A  4.93700e-02  2.25955e-02  6.09145e-01 #> BB515-A    -6.68526e-05 -3.01727e-05 -1.21999e-05 #> BB660-A     7.25687e-02  2.16664e-02  5.19117e-03 #> BB700-A     2.13325e-02  6.47322e-02  1.92574e-02 #> BB790-A     5.86199e-03  2.73473e-03  2.39552e-02 #> BUV395-A   -3.16921e-04 -1.94081e-04 -6.82352e-05 #> BUV496-A   -1.03874e-03 -7.87568e-04 -3.83751e-04 #> BUV563-A    5.34820e-02  1.18256e-02  2.30218e-03 #> BUV615-A    1.27041e-01  3.87130e-02  8.33019e-03 #> BUV661-A    1.29609e-01  4.69461e-02  9.83433e-03 #> BUV737-A    1.05708e-03  1.55556e-02  1.20126e-02 #> BUV805-A    2.41638e-05  8.65425e-05  9.39790e-03 #> BV421-A    -1.95171e-04 -7.76933e-05 -3.45835e-05 #> BV480-A    -8.99502e-04 -5.11925e-04 -3.20846e-04 #> BV510-A     3.09406e-04  1.02978e-04  6.77227e-05 #> BV570-A     1.09151e-01  2.85402e-02  6.54611e-03 #> BV605-A     1.21365e-01  3.52925e-02  9.52471e-03 #> BV650-A     7.23832e-02  2.28208e-02  4.93623e-03 #> BV711-A     1.44939e-03  2.94488e-02  1.10223e-02 #> BV750-A    -4.54062e-04  3.00004e-03  1.08283e-02 #> BV786-A     1.12239e-04  3.95568e-04  1.78838e-02 #> PE-A        8.31948e-02  1.84931e-02  3.40669e-03 #> PE-CF594-A  1.72793e-01  3.80472e-02  7.03978e-03 #> PE-Cy5-A    1.00000e+00  4.91045e-01  1.20956e-01 #> PE-Cy5.5-A  2.33135e-01  1.00000e+00  3.02046e-01 #> PE-Cy7-A    1.23589e-02  2.26059e-02  1.00000e+00"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"Internal function get_density_gates unique value subset_col, estimate derivatives marker (intensity values)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"","code":"getDensityDerivs(   dens,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"dens density object density marker string marker gate name needs match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak default 1800, biexponential scale","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"list dataframe density estimation corresponding 1st-4th derivatives, indicators local peaks, plateau_pre  element corresponds unique value subset_col  dataframe: rows correspond bins","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":null,"dir":"Reference","previous_headings":"","what":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"unique value subset_col, gate using density estimated derivatives identify cutoff shoulder (.e., point tapering ) relative peak marker (intensity values). strategy cutting shoulder mimics strategy gate relative unimodal background negative subpopulation, capable capturing dim subpopulations.","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"","code":"getDensityGates(   intens_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800,   neg_intensity_threshold = -1000 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, openCyto steps) intensity values cols = intensity value per marker, rows = sample marker string marker(s) gate names need match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated  Default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored  Default = 10 pos_peak_threshold either: numeric threshold identify positive peak dataframe supplying multiple marker gate. dataframe needs supplied 2 columns named marker pos_peak_threshold rows marker gate Default 1800 (note biexponential scale) marker neg_intensity_threshold numeric threshold filter \"negatively\" expressed cells density estimation avoid -compression difficulty distinguishing peaks gates  applied filter density estimation, cells < neg_intensity_threshold retained intensity matrix steps  Expects neg_intensity_threshold scale transformed data intens_dat  Default NULL: filters applied density estimation based cells corresponding subsets. Suggested biexp. transformed data -1000 corresponds ~-3300 original intensity scale)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"tibble gates/cutoffs marker unique subset found subset_col rows correspond unique values subset_col , columns correspond tomarker","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"","code":"# Create a fake dataset set.seed(100) intens_dat = tibble::tibble(                CD3_pos=rep(c(0, 1), each=50),                CD4 = rnorm(100, 100, 10),                CD8 = rnorm(100, 100, 10) )  # Run density gating, leaving other params at suggested defaults # number of bins suggested is 40 but default is at `bin_n = 512`, # which is the default for the R base density() function getDensityGates(intens_dat, marker=\"CD4\", subset_col=\"CD3_pos\", bin_n=40) #> # A tibble: 2 × 2 #>   CD3_pos   CD4 #>     <dbl> <dbl> #> 1       0  88.9 #> 2       1 113."},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"Internal function getDensityGates unique value subset_col, matrix storing calculations density gating contains: first fourth derivatives density, indicators local peaks, \"real peaks\", plateau_pre cutoff","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"","code":"getDensityMats(   intens_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, gated CD4/CD8) intensity values cols = intensity value per marker, rows = sample marker string marker gate name needs match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak '  default 1800, biexponential scale","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"tibble matrices marker containing calculations density gating unique subset found subset_col  rows correspond unique values subset_col,  cols correspond information density gating","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Determine the ","title":"Internal function: Determine the ","text":"Internal function getDensityGates","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Determine the ","text":"","code":"getDensityPeakCutoff(   dens_binned_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800,   dens_flip = FALSE )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Determine the ","text":"dens_binned_dat list dataframe output getDensityDerivs marker string marker gate name needs match exactly column name dens_binned_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak default 1800, biexponential scale dens_flip logical whether gating applied \"backwards\" peak positive peak want gate left peak instead right","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Determine the ","text":"list dataframe dens_binned_dat additional columns added peak(s) identified cutoff element corresponds unique value subset_col dataframe: rows correspond bins","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"Adds indicator column (0/1) intens_dat marker cutoffs indicated columns cutoffs","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"","code":"getGatedDat(intens_dat = intensity_dat, cutoffs, subset_col)"},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, openCyto steps) intensity values rows = cell cols intensity values marker cutoffs tibble gates/cutoffs markers gate  Expects cutoffs match format output getDensityGates() column corresponding marker, rows subsets defined subset_col subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"intens_dat additional columns attached marker cutoffs","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"naming convention tagged indicator columns tolower(<marker_name>_pos) 0 indicates negativity intensity < gate provided 1 indicates positivity intensity > gate provided","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"","code":"# Create a fake dataset set.seed(100) intens_dat = tibble::tibble(                CD3_pos = rep(c(0, 1), each = 50),                CD4 = rnorm(100, 100, 10),                CD8 = rnorm(100, 100, 10) )  # Run getDensityGates to obtain the gates gates = getDensityGates(intens_dat, marker = \"CD4\", subset_col = \"CD3_pos\", bin_n = 40)  # Tag on the 0/1 on intens_dat intens_dat_2 = getGatedDat(intens_dat, cutoffs = gates, subset_col = \"CD3_pos\")  # intens_dat_2 now has the cd4_pos tagged on head(intens_dat_2) #> # A tibble: 6 × 4 #>   CD3_pos   CD4   CD8 cd4_pos #>     <dbl> <dbl> <dbl>   <dbl> #> 1       0  95.0  96.7       1 #> 2       0 101.  114.        1 #> 3       0  99.2  95.3       1 #> 4       0 109.  108.        1 #> 5       0 101.   85.4       1 #> 6       0 103.   96.0       1"},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the percentage of positive cells for specific subpopulations — getPerc","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"Expects data input output get_gated_dat indicator columns specific naming convention (see ).","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"","code":"getPerc(   intens_dat,   num_marker,   denom_marker,   expand_num = FALSE,   expand_denom = FALSE,   keep_indicators = TRUE )"},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"intens_dat dataframe gated data indicator columns per marker interest (specify num_marker denom_marker) naming convention marker_pos per marker values 0 indicate negative-, 1 indicate positive-expressing num_marker string marker(s) specify numerator subpopulations interest  See expand_num argument examples specify denom_marker string marker(s) specify denominator subpopulations interest  See expand_denom argument examples specify. expand_num logical, accepts TRUE FALSE default FALSE  expand_num = TRUE, currently considers pairs markers specified num_marker numerator subpopulation calculations (e.g., CD4+ & CD8- CD3+)  expand_num = FALSE, considers marker specified num_marker individually numerator subpopulation calculations (e.g., CD4+ CD3+) expand_denom logical, accepts TRUE FALSE default FALSE  expand_denom = TRUE, currently considers 1 marker num_marker unique combinations denom_marker generate list subpopulations  e.g., denom_marker = c(\"CD8\"), num_marker = c(\"LAG3\", \"KI67\"), expand_denom = TRUE, subpopulations include:  1. LAG3+ CD8+, LAG3- CD8+, LAG3+ CD8-, LAG3- CD8-,  2. KI67+ CD8+, KI67- CD8+, KI67+ CD8-, KI67- CD8-,  3. KI67+ (LAG3+ & CD8+), KI67- (LAG3+ & CD8+), KI67+ (LAG3+ & CD8-), KI67- (LAG3+ & CD8-)...etc.,  4. LAG3+ (KI67+ & CD8+), LAG3- (KI67+ & CD8+), LAG3+ (KI67+ & CD8-), LAG3- (KI67+ & CD8-)...etc.,  expand_denom = FALSE, generates list subpopulations based unique combinations denom_marker (e.g., denom_marker = c(\"CD4\") expand_denom = FALSE considers subpopulations denominator CD4+ CD4- whereas denom_marker = c(\"CD4\", \"CD8\" expand_denom = FALSE consider subpopulations denominators (CD4- & CD8-), (CD4+ & CD8-), (CD4- & CD8+) (CD4+ & CD8+)) keep_indicators logical, accepts TRUE FALSE default TRUE  keep_indicators = TRUE, return indicator columns 0/1 specify markers considered numerator denominators subpopulations.   Naming convention numerator cols <marker>_POS denominator cols <marker>_POS_D.  sets columns, 0 indicates considered negative cells, 1 indicates considered positive cells NA_real_ indicates consideration subpopulation.   useful matching percentage data potentially different naming conventions avoid exact string matches subpopulation  Take note order also matters matching strings: \"CD4+ & CD8- CD3+\" different \"CD8- & CD4+ CD3+\"","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"tibble containing percentage cells rows correspond subpopulation specified subpopulation, n_num indicates number cells satisifies numerator conditions, n_denom indicates number cells satisifies denominator conditions, perc = n_num divided n_denom unless n_denom = 0, perc = NA_real_","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"subpopulations defined (num marker(s)) (denom marker(s)) num denotes numerator, denom denotes denominator (shorthands used function arguments)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  # Create a fake dataset set.seed(100) intens_dat = tibble::tibble(                CD3_pos = rep(c(0, 1), each = 50),                CD4 = rnorm(100, 100, 10),                CD8 = rnorm(100, 100, 10) )  # Run getDensityGates to obtain the gates gates = getDensityGates(intens_dat, marker = \"CD4\", subset_col = \"CD3_pos\", bin_n = 40)  # Tag on the 0/1 on intens_dat intens_dat_2 = getGatedDat(intens_dat, cutoffs = gates, subset_col = \"CD3_pos\")  # Get percentage for CD4 based on gating getPerc(intens_dat_2, num_marker = c(\"CD4\"), denom_marker = \"CD3\") #> # A tibble: 4 × 6 #>   subpopulation      n_num n_denom  perc CD4_POS CD3_POS_D #>   <chr>              <int>   <int> <dbl>   <dbl>     <dbl> #> 1 CD4_NEG_OF_CD3_NEG     3      50     6       0         0 #> 2 CD4_POS_OF_CD3_NEG    47      50    94       1         0 #> 3 CD4_NEG_OF_CD3_POS    42      50    84       0         1 #> 4 CD4_POS_OF_CD3_POS     8      50    16       1         1"},{"path":"https://leejasme.github.io/staRgate/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://leejasme.github.io/staRgate/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://leejasme.github.io/staRgate/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://leejasme.github.io/staRgate/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://leejasme.github.io/staRgate/reference/staRgate-package.html","id":null,"dir":"Reference","previous_headings":"","what":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","title":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","text":"R-based automated gating pipeline flow cytometry data designed mimic manual gating strategy defining flow biomarker positive populations relative unimodal background population include cells varying intensities marker expression. pipeline’s main feature flexible density-based gating strategy capable capturing varying scenarios based marker expression patterns analyze 29-marker flow panel characterizes T-cell lineage, differentiation, functional states.","code":""},{"path":[]},{"path":"https://leejasme.github.io/staRgate/reference/staRgate-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","text":"Maintainer: Jasme Lee leej22@mskcc.org (ORCID)","code":""}]
