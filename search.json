[{"path":"https://leejasme.github.io/staRgate/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 staRgate authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Tutorial: Running the pipeline","text":"staRgate automated gating pipeline process analyze flow cytometry data characterize lineage, differentiation functional states T-cells. pipeline designed mimic manual gating defining flow biomarker positive populations relative unimodal background population include cells varying intensities marker expression. achieved via estimating kernel density intensity distribution corresponding derivatives. pipeline integrates density gating method conjuction pre-processing steps achieved via R package openCyto optional step flowAI. flow data stored within R GatingSet object, makes easily transferable flow cytometry workflows available BioConductor. vignette walk run {staRgate} pipeline starting importing flow cytometry standard (FCS) file R preprocessing gating, well identifying T-cell subpopulations downstream analysis. pipeline returns results single-cell level well summarized sample-level data (percentages T-cell cells identifying subpopulations). illustration purposes, example FCS file used vignette stored package data concatenated file limited first 30k events/cells acquired reduce run time file size. running {staRgate} gate flow cytometry data, recommended perform quality checks (QC) gate placements ensure reasonable. suggest use ridgeplots addition ggcyto::autoplot visualize density distributions per marker across samples. examining large batch samples, downsampling, random sample 10k CD3+ cells, make QC process manageable. addition, random spot checks samples also helpful QC detect edge cases. Currently tutorial, extend QC steps suggest lean examples put together ridgeplot example. near future, hope incorporate examples additional QC steps well, stay tuned!","code":""},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Tutorial: Running the pipeline","text":"{staRgate} package relies Biocondcutor R packages. installing {staRgate}, first setup Bioconductor install dependencies. instructions instructions installing Bioconductor essential dependencies running {staRgate} package include: flowCore, flowWorkspace. following packages needed fully run pipeline shown Tutorial, required {staRgate} code chunks run: openCyto, ggplot2, ggcyto, gt","code":"if (!require(\"BiocManager\", quietly = TRUE)) {   install.packages(\"BiocManager\") } # Load libraries library(staRgate) library(openCyto) library(flowWorkspace) #> As part of improvements to flowWorkspace, some behavior of #> GatingSet objects has changed. For details, please read the section #> titled \"The cytoframe and cytoset classes\" in the package vignette: #>  #>   vignette(\"flowWorkspace-Introduction\", \"flowWorkspace\") library(flowCore) # Just for plotting in the vignette library(ggplot2) library(ggcyto) #> Loading required package: ncdfFlow #> Loading required package: BH  # Set up dynamic variables pt_samp_nm <- \"flow_sample_1\"  ## File path to the FCS file path_fcs <- system.file(\"extdata\", \"example_fcs.fcs\", package = \"staRgate\", mustWork = TRUE)  ## File path to the compensation matrix csv file ## Expect format to match flowJo exported version path_comp_mat <- system.file(\"extdata\", \"comp_mat_example_fcs.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path for outputs/saving # Maybe not the best sol, but create a temp dir? path_out <- tempdir() # Print the path_out for user to see path_out #> [1] \"/tmp/RtmphFEcj5\"  ## File path Gating template gtFile <- system.file(\"extdata\", \"gating_template_x50_tcell.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path to biexp parameters ## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec ## full name should contain the channel/dye name # 3 remaining cols fill in with desired parameter values path_biexp_params <- system.file(\"extdata\", \"biexp_transf_parameters_x50.csv\", package = \"staRgate\", mustWork = TRUE)  ## File path to positive peak thresholds path_pos_peak_thresholds <- system.file(\"extdata\", \"pos_peak_thresholds.csv\", package = \"staRgate\", mustWork = TRUE)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"input-files-and-function-parameters","dir":"Articles","previous_headings":"","what":"Input files and function parameters","title":"Tutorial: Running the pipeline","text":"order run pipeline, user must data flow cytometry standard (FCS) format. usually output flowJo. input files expected comma-separated values (csv) files. Please see inst folder package examples formats. Matrix column row names correspond channel names, cell values correspond spillover correction applied. can exported csv flowJo’s options table specifying parameters (negative decades, width basis positive decades) applied listed channels gating template required run pre-gating via openCyto package includes gating template tailored gating panel T-cell markers. examples modify gating template, please refer openCyto documentation. systematic grid search, found bin sizes 40 50 works well density gating things keep mind debugging/iterating gating: saving path name (.e., rerunning code), GatingSet folder flowWorkspace::save_gs() command needs deleted openCyto save , otherwise, encounter error related invalid path flowWorkspace::save_gs() function","code":""},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Tutorial: Running the pipeline","text":"example gating 1 FCS sample.","code":""},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"import-fcs","dir":"Articles","previous_headings":"Example","what":"Import FCS","title":"Tutorial: Running the pipeline","text":"","code":"# Read in gating template dtTemplate <- data.table::fread(gtFile)  # Load the FCS gt_tcell <- openCyto::gatingTemplate(gtFile) #> expanding pop: -/++/- #> Adding population:fsc_ssc_qc #> Adding population:nonDebris #> Adding population:singlets #> Adding population:cd14-cd19- #> Adding population:live #> Adding population:cd3 #> Adding population:cd4+ #> Adding population:cd8+ #> Adding population:cd4+cd8+ #> Adding population:cd4-cd8+ #> Adding population:cd4+cd8- #> Adding population:cd4-cd8-  cs <- flowWorkspace::load_cytoset_from_fcs(path_fcs)  # Create a GatingSet of 1 sample gs <- flowWorkspace::GatingSet(cs)  # Check- how many cells is in the FCS file? n_root <- flowWorkspace::gh_pop_get_count(gs, \"root\")  # The example FCS has 30000 cells n_root #> [1] 30000"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"compensation","dir":"Articles","previous_headings":"Example","what":"Compensation","title":"Tutorial: Running the pipeline","text":"","code":"# Apply comp gs <- getCompGS(gs, path_comp_mat = path_comp_mat)  # Can check that the comp was applied chk_cm <- flowWorkspace::gh_get_compensations(gs)  # Not aware of an accessor that we can use for this head(methods::slot(chk_cm, \"spillover\"), 2) #>          AF700-A     APC-A APC-f750-A      BB515-A    BB660-A    BB700-A #> AF700-A 1.000000 0.0248301  0.2492840  0.009679220 0.00268438 0.04732480 #> APC-A   0.132334 1.0000000  0.0337338 -0.000160633 0.01598550 0.00443383 #>            BB790-A    BUV395-A     BUV496-A     BUV563-A   BUV615-A   BUV661-A #> AF700-A 0.01730770 0.001813870  1.81722e-03  1.45041e-03 0.00249455 0.00220337 #> APC-A   0.00122597 0.000471851 -5.18352e-05 -3.25396e-05 0.00127167 0.11436300 #>          BUV737-A   BUV805-A      BV421-A     BV480-A     BV510-A     BV570-A #> AF700-A 0.1387160 0.03310420  5.11994e-05 0.003390200 2.60901e-03 2.45899e-03 #> APC-A   0.0221613 0.00527436 -4.09868e-04 0.000113668 4.37466e-05 5.85607e-05 #>            BV605-A    BV650-A   BV711-A    BV750-A    BV786-A        PE-A #> AF700-A 0.00358515 0.00445768 0.2127300 0.08483990 0.04394760 0.006840740 #> APC-A   0.00085079 0.13844100 0.0285134 0.00973321 0.00417643 0.000280757 #>         PE-CF594-A  PE-Cy5-A PE-Cy5.5-A  PE-Cy7-A #> AF700-A 0.02926360 0.0164829  0.3260510 0.1032330 #> APC-A   0.00541964 0.2677470  0.0810869 0.0215633"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"transformation","dir":"Articles","previous_headings":"Example","what":"Transformation","title":"Tutorial: Running the pipeline","text":"transformation applied channels : biexponential extra negative decades = 0.5, positive decades = 4.5 width basis = -30 structure table parameters (.csv format) first column flurochrome names corresponding panel, followed parameters. Currently, package supports biexponetial transformation channels getBiexpTransformGS() function. However, user may choose create transformation list explicitly transformations (e.g., archsin) desired. Note flowWorkspace package also allows automated transformation calculation “guessing” appropriate parameters. chose explicitly specify biexponential transformation fixed parameters channels match manual gating strategy used flowJo direct comparison {staRgate} manual gating results.","code":"tbl_biexp_params <-   utils::read.csv(path_biexp_params) |>   janitor::clean_names(case=\"all_caps\")  head(tbl_biexp_params, 2) #>   FULL_NAME EXT_NEG_DEC WIDTH_BASIS POSITIVE_DEC #> 1  BUV395-A         0.5         -30          4.5 #> 2  BUV496-A         0.5         -30          4.5 # Save the pre-transformed data to compare ranges  # And check that transformation was applied dat_pre_transform <-   flowWorkspace::gh_pop_get_data(gs) |>   flowCore::exprs()  # Apply biexp trans gs <- getBiexpTransformGS(gs, path_biexp_params = path_biexp_params)  ## **Optional**-- to check what pre-transformed data against post # save the post-transformed data dat_post_transform <-   flowWorkspace::gh_pop_get_data(gs) |>   flowCore::exprs()  ## **Optional**-- to check that the transformation worked on all provided channels! ## Commented out for ease of length  # summary(dat_pre_transform) # summary(dat_post_transform)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"pre-gating","dir":"Articles","previous_headings":"Example","what":"Pre-gating","title":"Tutorial: Running the pipeline","text":"context, pre-gating defined gating root population CD3+, CD4+/CD8+ subsets pass data density gating step. flowAI step serves quality control (QC) match first Time gate step typically done manual gating. possible, however, user may choose skip step flowAI excludes many cells. first step gating template QC step especially important include user chooses exclude flowAI step. tutorial, skip flowAI step.","code":"# Pre-gating up to CD4/8+ with `r BiocStyle::Biocpkg(\"openCyto\")` ## Set seed using today's date set.seed(glue::glue({   format(Sys.Date(), format = \"%Y%m%d\") }))  openCyto::gt_gating(gt_tcell, gs) #> Gating for 'fsc_ssc_qc' #> done! #> done. #> Gating for 'nonDebris' #> done! #> done. #> Gating for 'singlets' #> done! #> done. #> Gating for 'cd14-cd19-' #> done! #> done. #> Gating for 'live' #> done! #> done. #> Gating for 'cd3' #> done! #> done. #> Gating for 'cd8+' #> done! #> done. #> Gating for 'cd4+' #> done! #> done. #> Population 'cd4-cd8-' #> done. #> Population 'cd4+cd8-' #> done. #> Population 'cd4-cd8+' #> done. #> Population 'cd4+cd8+' #> done. #> finished. ## Check autoplot ggcyto::autoplot(gs[[1]])"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"extract-intensity-matrix","dir":"Articles","previous_headings":"Example","what":"Extract intensity matrix","title":"Tutorial: Running the pipeline","text":"Grab channel marker names gs object extracting intensity_matrix, labeled channel names marker names marker_chnl_names mapping created used rename column names marker names, make calling appropriate columns easier analyzing data Next grab intensity values indicators pre-gating steps.","code":"## Grab marker names from GatingSet for labeling col names in intensity matrix ## Can skip this step if you know the exact namings of the marker names in your FCS files # In that case, supply a string is fine: # marker_chnl_names = c(\"CD45RA\", \"CCR7\", \"LAG3\", ...) marker_chnl_names <-   flowWorkspace::gh_pop_get_data(gs) |>   flowWorkspace::markernames() |>   data.frame(\"marker_full\" = _) |>   tibble::rownames_to_column(var = \"chnl\") |>   # clean up the names   dplyr::mutate(     marker_full = janitor::make_clean_names(marker_full, replace = c(\"-\" = \"\", \"_\" = \"\", \" \" = \"\")) |> toupper()   ) |>   # Reorder the marker channel names to start with CD3, CD4, CD8 then the rest   dplyr::arrange(match(marker_full, c(\"CD3\", \"CD4\", \"CD8\"))) |>    # Clean up   dplyr::mutate(marker_full =                    dplyr::case_when(marker_full == \"FOX_P3\" ~ \"FOXP3\",                                    .default = marker_full))  # For our Tcell panel, we only want to apply the density gating on # these 23 markers markers_to_gate = c(\"CD45RA\", \"ICOS\", \"CD25\", \"TIM3\",                      \"CD27\", \"CD57\", \"CXCR5\", \"CCR4\",                      \"CCR7\", \"HLADR\", \"CD28\", \"PD1\",                      \"LAG3\", \"CD127\", \"CD38\", \"TIGIT\",                      \"EOMES\", \"CTLA4\", \"FOXP3\", \"GITR\",                     \"TBET\", \"KI67\", \"GZM_B\") # Extract intensity matrix from GatingSet object ## Grab the intensity matrix from GatingSet ## the gh_pop_get_indices grabs the 0/1 for whether gated as CD3 intensity_dat <-   cbind(     # This grabs the intensity matrix with intensity values     flowWorkspace::gh_pop_get_data(gs) |>       flowCore::exprs(),     # Each of these grabs the 0/1 for gated as positive or negative for     # each step     \"fsc_ssc_qc\" = flowWorkspace::gh_pop_get_indices(gs, y = \"fsc_ssc_qc\"),     \"nonDebris\" = flowWorkspace::gh_pop_get_indices(gs, y = \"nonDebris\"),     \"singlets\" = flowWorkspace::gh_pop_get_indices(gs, y = \"singlets\"),     \"cd14_neg_19_neg\" = flowWorkspace::gh_pop_get_indices(gs, y = \"cd14-cd19-\"),     \"live\" = flowWorkspace::gh_pop_get_indices(gs, y = \"live\"),     \"cd3_pos\" = flowWorkspace::gh_pop_get_indices(gs, y = \"cd3\"),     \"cd4_pos\" = flowWorkspace::gh_pop_get_indices(gs, y = \"cd4+\"),     \"cd8_pos\" = flowWorkspace::gh_pop_get_indices(gs, y = \"cd8+\")   ) |>   # The intensity matrix is a matrix object. Convert to tibble.   tibble::as_tibble() |>   # Rename with marker names with a named vector   # Where the names = value to rename to (marker names)    # The values of the vector = current names (Channel names)   dplyr::rename(stats::setNames(marker_chnl_names$chnl,                                  as.character(marker_chnl_names$marker_full))) |>   dplyr::mutate(     # Create a 4-level category for cd4, cd8 neg/pos     cd4_pos_cd8_pos = dplyr::case_when(       cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 1 ~ \"cd4_pos_cd8_pos\",       cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 0 ~ \"cd4_pos_cd8_neg\",       cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 1 ~ \"cd4_neg_cd8_pos\",       cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 0 ~ \"cd4_neg_cd8_neg\"     )   )  ## Preview of intensity matrix head(intensity_dat, 2) #> # A tibble: 2 × 44 #>   `FSC-A` `FSC-H` `FSC-W` `SSC-A` `SSC-H` `SSC-W`  KI67  TBET GZM_B   PD1  LAG3 #>     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1  14579.  12925.  91156.   6783.   6899.  59440.  898.  995.  949.  922. 1184. #> 2  47535.  36802. 124831.  21010.  20507.  79210.  732. 1178.  775.  914. 1169. #> # ℹ 33 more variables: CD127 <dbl>, CD38 <dbl>, CD45RA <dbl>, CD4 <dbl>, #> #   ICOS <dbl>, CD25 <dbl>, TIM3 <dbl>, CD27 <dbl>, CD8 <dbl>, CD57 <dbl>, #> #   CXCR5 <dbl>, LD <dbl>, CD1419 <dbl>, CCR4 <dbl>, CCR7 <dbl>, HLADR <dbl>, #> #   CD3 <dbl>, CD28 <dbl>, TIGIT <dbl>, EOMES <dbl>, CTLA4 <dbl>, FOXP3 <dbl>, #> #   GITR <dbl>, Time <dbl>, fsc_ssc_qc <dbl>, nonDebris <dbl>, singlets <dbl>, #> #   cd14_neg_19_neg <dbl>, live <dbl>, cd3_pos <dbl>, cd4_pos <dbl>, #> #   cd8_pos <dbl>, cd4_pos_cd8_pos <chr>"},{"path":[]},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"pseudo-negative-control","dir":"Articles","previous_headings":"Example > Gating on T-cell subsets","what":"Pseudo-negative control","title":"Tutorial: Running the pipeline","text":"T-cell panel, recommend using CD3- cells pseudo-negative control gating CD127 CD28 two markers expected predominantly negatively-expressing CD3- cells. mimics isotype-based gating approach. recommend using 95th percentile CD3- distributions. ensure capture CD3- cells, first filter live cells cd3_pos == 0","code":"gates_pseudo_neg =    dplyr::filter(intensity_dat, live == 1, cd3_pos == 0) |>   dplyr::select(CD127, CD28) |>   dplyr::summarise(     dplyr::across(c(CD127, CD28),                   ~ quantile(.x, 0.95))   )"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"empirical-gating","dir":"Articles","previous_headings":"Example > Gating on T-cell subsets","what":"Empirical gating","title":"Tutorial: Running the pipeline","text":"functional differentiation markers borrow CD3- pseudo-negative control, gate empirically based CD3+ density distribution per marker. suggested strategy based CD3+, can customized based string corresponding column name supplied subset_col get_density_gates function suggested number bins density estimation 40 level smoothing required reduce noise picking false peaks. multiple samples batch experiment run (samples processed together), recommend borrow information samples pooling CD3+ across batch applying density gating. interested pooling across experiment runs, consider visualizing batch-level intensity shifts variations pooling samples together. illustration purposes, apply density gating markers.","code":"# Density gating parameters peak_r <- 10 bin_i <- 40  neg_intensity_thres <- -1000  # select a few markers to gate example_markers <- c(\"LAG3\", \"CCR7\", \"CD45RA\")  # Read in positive peak thresholds pos_thres <- utils::read.csv(path_pos_peak_thresholds) |>   janitor::clean_names(case = \"all_caps\") # Show the exact output from the get_density_gates() function dens_gates_pre <-   dplyr::filter(intensity_dat, cd3_pos == 1) |>   getDensityGates(     intens_dat = _,     marker = example_markers,     subset_col = \"cd3_pos\",     bin_n = bin_i,     peak_detect_ratio = peak_r,     pos_peak_threshold = pos_thres,     neg_intensity_threshold = neg_intensity_thres   )  # Since we apply density gating on CD3+ cells but # Would like to calculate subpopulations with CD4+ and CD8+ as # the starting parent population, we need to add corresponding rows dens_gates <-   # Stack the pseudo-neg gated markers and empirically gated markers   dplyr::bind_cols(dens_gates_pre, gates_pseudo_neg) |>   tibble::add_row() |>   tibble::add_row() |>   tibble::add_row() |>   dplyr::mutate(cd4_pos_cd8_pos = c(\"cd4_neg_cd8_neg\", \"cd4_pos_cd8_neg\", \"cd4_neg_cd8_pos\", \"cd4_pos_cd8_pos\")) |>   tidyr::fill(-cd4_pos_cd8_pos, .direction = \"down\")  # View updated gates with the col for CD4/CD8 dens_gates #> # A tibble: 4 × 7 #>   cd3_pos  LAG3  CCR7 CD45RA CD127  CD28 cd4_pos_cd8_pos #>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <chr>           #> 1       1 1634. 1768.  1486. 1327. 1251. cd4_neg_cd8_neg #> 2       1 1634. 1768.  1486. 1327. 1251. cd4_pos_cd8_neg #> 3       1 1634. 1768.  1486. 1327. 1251. cd4_neg_cd8_pos #> 4       1 1634. 1768.  1486. 1327. 1251. cd4_pos_cd8_pos  # get indicator col example_intensity_gated <-   getGatedDat(intensity_dat,     subset_col = \"cd4_pos_cd8_pos\",     cutoffs = dens_gates   )"},{"path":[]},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"lag3-for-all-cd3","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"LAG3 for all CD3+","title":"Tutorial: Running the pipeline","text":"","code":"# Plot the gate for visual intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(LAG3)) +   geom_vline(     data = dens_gates,     aes(xintercept = LAG3),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of LAG3 intensity on all CD3+. Gate identifed by {staRgate} in blue.\")"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"lag3-by-cd4-and-cd8-subsets","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"LAG3 by CD4 and CD8 subsets","title":"Tutorial: Running the pipeline","text":"","code":"# If by CD4/CD8, intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(LAG3)) +   geom_vline(     data = dens_gates,     aes(xintercept = LAG3),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of LAG3 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +   facet_wrap(~cd4_pos_cd8_pos)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"ccr7-for-all-cd3","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"CCR7 for all CD3+","title":"Tutorial: Running the pipeline","text":"","code":"# For CCR7 intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(CCR7)) +   geom_vline(     data = dens_gates,     aes(xintercept = CCR7),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of CCR7 intensity on all CD3+. Gate identifed by {staRgate} in blue.\")"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"ccr7-by-cd4-and-cd8-subsets","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"CCR7 by CD4 and CD8 subsets","title":"Tutorial: Running the pipeline","text":"","code":"# If by CD4/CD8, intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(CCR7)) +   geom_vline(     data = dens_gates,     aes(xintercept = CCR7),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of CCR7 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +   facet_wrap(~cd4_pos_cd8_pos)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"cd45ra-for-all-cd3","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"CD45RA for all CD3+","title":"Tutorial: Running the pipeline","text":"","code":"# For CD45RA intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(CD45RA)) +   geom_vline(     data = dens_gates,     aes(xintercept = CD45RA),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of CD45RA intensity on all CD3+. Gate identifed by {staRgate} in blue.\")"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"cd45ra-by-cd4-and-cd8-subsets","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"CD45RA by CD4 and CD8 subsets","title":"Tutorial: Running the pipeline","text":"","code":"# If by CD4/CD8, intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(CD45RA)) +   geom_vline(     data = dens_gates,     aes(xintercept = CD45RA),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of CD45RA intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +   facet_wrap(~cd4_pos_cd8_pos)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"cd127-for-all-cd3","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"CD127 for all CD3+","title":"Tutorial: Running the pipeline","text":"","code":"# For CD127 intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(CD127)) +   geom_vline(     data = dens_gates,     aes(xintercept = CD127),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of CD127 intensity on all CD3+. Gate identifed by {staRgate} in blue.\")"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"cd127-by-cd4-and-cd8-subsets","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"CD127 by CD4 and CD8 subsets","title":"Tutorial: Running the pipeline","text":"","code":"# If by CD4/CD8, intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(CD127)) +   geom_vline(     data = dens_gates,     aes(xintercept = CD127),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of CD127 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +   facet_wrap(~cd4_pos_cd8_pos)"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"cd28-for-all-cd3","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"CD28 for all CD3+","title":"Tutorial: Running the pipeline","text":"","code":"# For CD28 intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(CD28)) +   geom_vline(     data = dens_gates,     aes(xintercept = CD28),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of CD28 intensity on all CD3+. Gate identifed by {staRgate} in blue.\")"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"cd28-by-cd4-and-cd8-subsets","dir":"Articles","previous_headings":"Example > Visualizing the gates","what":"CD28 by CD4 and CD8 subsets","title":"Tutorial: Running the pipeline","text":"","code":"# If by CD4/CD8, intensity_dat |>   dplyr::filter(cd3_pos == 1) |>   # additional step to remove large intensity values only when density gating.   # Still kept in the data   dplyr::filter(!(dplyr::if_any(dplyr::all_of(markers_to_gate), ~ .x < neg_intensity_thres))) |>   ggplot() +   geom_density(aes(CD28)) +   geom_vline(     data = dens_gates,     aes(xintercept = CD28),     color = \"blue\",     linetype = \"dashed\"   ) +   labs(subtitle = \"Distribution of CD28 intensity on all CD3+. Gate identifed by {staRgate} in blue.\") +   facet_wrap(~cd4_pos_cd8_pos)"},{"path":[]},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"getting-percentage-data","dir":"Articles","previous_headings":"Example","what":"Getting percentage data","title":"Tutorial: Running the pipeline","text":"can summarize single-cell level data counts percentages cells combinations markers. subpopulations, denominator defined parent population numerator population interest parent population. ndn_d refers number markers considered denominator nn number markers considered numerator. 29-marker panel, denominator specified CD4 CD8 subsets, nd=2n_d = 2 n=23n = 23 markers interest. getPerc function allows user list markers interest numerator denominator example , consider CD4 CD8 subsets key parent populations interest (denominator) three markers gated using c(\"LAG3\", \"CCR7\", \"CD45RA\") (numerator markers). additional arguments expand_num expand_denom generates different lists subpopulations calculate counts/percentages : expand_num: calculations consider pairs numerator markers included?, expand_denom: calculations consider combinations numerator marker parent populations specified denominator? Numerator: Positive negative marker specified Denominator: Combinations positive negative markers specified LAG3+/- CD4- & CD8- LAG3+/- CD4+ & CD8- LAG3+/- CD4+ & CD8+ LAG3+/- CD4- & CD8+ least 2 markers must included numerator Denominator: Combinations positive negative marker(s) LAG3+/- CD4+/- KI67+/- CD4+/- LAG3- KI67-  CD4+/- LAG3+ KI67-  CD4+/- LAG3- KI67+  CD4+/- LAG3+ KI67+  CD4+/- least 2 markers must included numerator Denominator: Combinations positive negative marker(s), combinations positive negative marker(s) denominator one marker numerator LAG3+/- CD4+/- KI67+/- CD4+/- LAG3+/- CD4-KI67- LAG3+/- CD4-KI67+ LAG3+/- CD4+KI67- LAG3+/- CD4+KI67+ KI67+/- CD4-LAG3- KI67+/- CD4-LAG3+ KI67+/- CD4+LAG3- KI67+/- CD4+LAG3+ least 3 markers must included numerator Denominator: Combinations positive negative marker(s), combinations positive negative marker(s) denominator one marker numerator LAG3+/- CD4+/- KI67+/- CD4+/- CTLA4+/- CD4+/- LAG3+/- CD4-KI67- LAG3+/- CD4-KI67+ LAG3+/- CD4+KI67- LAG3+/- CD4+KI67+ KI67+/- CD4-LAG3- KI67+/- CD4-LAG3+ KI67+/- CD4+LAG3- KI67+/- CD4+LAG3+ …. LAG3- KI67-  CD4+/- LAG3+ KI67-  CD4+/- LAG3- KI67+  CD4+/- LAG3+ KI67+  CD4+/- … LAG3+ KI67+  CD4+/- & CTLA4+/- … keep_indicators argument provides 0/1 marker considered numerator denominator subpopulation. especially useful merging onto data format. example, matching strings: “CD4+ & CD8- CD3+” different “CD8- & CD4+ CD3+” “CD4+ CD8- CD3+” show examples four combinations expand_num expand_denom arguments. example expand_num = FALSE expand_denom = FALSE, keep_indicators = TRUE illustrate columns get _POS _POS_D. examples use keep_indicators = FALSE.","code":"example_perc1 <-   # Should only count the CD3+ cells   dplyr::filter(example_intensity_gated, cd3_pos == 1) |>    getPerc(     intens_dat = _,     num_marker = example_markers,     denom_marker = c(\"CD4\", \"CD8\"),     expand_num = FALSE,     expand_denom = FALSE,     keep_indicators = TRUE   )  # For display only, group based on the denominators and # simplify the names to be numerators example_perc1 |>    tidyr::separate_wider_delim(subpopulation,     delim = \"_OF_\",     names = c(\"num\", \"denom\"),     cols_remove = FALSE   ) |>   dplyr::mutate(denom = paste(\"Denom = \", denom)) |>   dplyr::group_by(denom) |>   dplyr::select(-subpopulation) |>   gt::gt() |>   gt::fmt_number(     columns = \"perc\",     decimals = 1   ) example_perc2 <-   # Should only count the CD3+ cells   dplyr::filter(example_intensity_gated, cd3_pos == 1) |>   getPerc(     intens_dat = _,     num_marker = example_markers,     denom_marker = c(\"CD4\", \"CD8\"),     expand_num = TRUE,     expand_denom = FALSE,     keep_indicators = FALSE   )  # For display only, group based on the denominators and # simplify the names to be numerators example_perc2 |>   tidyr::separate_wider_delim(subpopulation,     delim = \"_OF_\",     names = c(\"num\", \"denom\"),     cols_remove = FALSE   ) |>   dplyr::mutate(denom = paste(\"Denom = \", denom)) |>   dplyr::group_by(denom) |>   dplyr::select(-subpopulation) |>   gt::gt() |>   gt::fmt_number(     columns = \"perc\",     decimals = 1   ) example_perc3 <-   # Should only count the CD3+ cells   dplyr::filter(example_intensity_gated, cd3_pos == 1) |>   getPerc(     intens_dat = _,     num_marker = example_markers,     denom_marker = c(\"CD4\", \"CD8\"),     expand_num = FALSE,     expand_denom = TRUE,     keep_indicators = FALSE   )  # For display only, group based on the denominators and # simplify the names to be numerators example_perc3 |>    tidyr::separate_wider_delim(subpopulation,     delim = \"_OF_\",     names = c(\"num\", \"denom\"),     cols_remove = FALSE   ) |>   dplyr::mutate(denom = paste(\"Denom = \", denom)) |>   dplyr::group_by(denom) |>   dplyr::select(-subpopulation) |>   gt::gt() |>   gt::fmt_number(     columns = \"perc\",     decimals = 1   ) example_perc4 <-   # Should only count the CD3+ cells   dplyr::filter(example_intensity_gated, cd3_pos == 1) |>   getPerc(     intens_dat = _,     num_marker = example_markers,     denom_marker = c(\"CD4\", \"CD8\"),     expand_num = TRUE,     expand_denom = TRUE,     keep_indicators = FALSE   )  # For display only, group based on the denominators and # simplify the names to be numerators example_perc4 |>   tidyr::separate_wider_delim(subpopulation,     delim = \"_OF_\",     names = c(\"num\", \"denom\"),     cols_remove = FALSE   ) |>   dplyr::mutate(denom = paste(\"Denom = \", denom)) |>   dplyr::group_by(denom) |>   dplyr::select(-subpopulation) |>   gt::gt() |>   gt::fmt_number(     columns = \"perc\",     decimals = 1   )"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"optional-adding-density-gates-back-to-gatingset","dir":"Articles","previous_headings":"Example","what":"Optional: Adding density gates back to GatingSet","title":"Tutorial: Running the pipeline","text":"Let’s add gate LAG3 CD4+ CD8+. good visualization see sequential gating steps applied sample.  running {staRgate} gate flow cytometry data, recommended perform quality checks (QC) gate placements ensure reasonable. suggest use ridgeplots addition ggcyto::autoplot function visualize density distributions per marker across samples. examining large batch samples, downsampling, random sample 10k CD3+ cells, make QC process manageable. addition, random spot checks samples also helpful QC detect edge cases. Currently tutorial, extend QC steps suggest lean examples put together ridgeplot example. near future, hope incorporate examples additional QC steps well, stay tuned!","code":"# Grab gate as a numeric current_gate <-   dens_gates |>   dplyr::filter(cd4_pos_cd8_pos == \"cd4_neg_cd8_pos\") |>   dplyr::pull(LAG3)  # Apply using gs_add_gating-method and # We want a boundary gate openCyto::gs_add_gating_method(   gs,   alias = \"lag3_cd8\",   pop = \"+\",   parent = \"cd4-cd8+\",   dims = \"LAG3\",   gating_method = \"boundary\",   gating_args = list(min = current_gate, max = Inf) )  current_gate <-   dens_gates |>   dplyr::filter(cd4_pos_cd8_pos == \"cd4_pos_cd8_neg\") |>   dplyr::pull(LAG3)  openCyto::gs_add_gating_method(   gs,   alias = \"lag3_cd4\",   pop = \"+\",   parent = \"cd4+cd8-\",   dims = \"LAG3\",   gating_method = \"boundary\",   gating_args = list(min = current_gate, max = Inf) )  ggcyto::autoplot(gs[[1]])"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Tutorial: Running the pipeline","text":"","code":"sessionInfo() #> R version 4.5.1 (2025-06-13) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggcyto_1.36.1        ncdfFlow_2.54.0      BH_1.87.0-1          #> [4] ggplot2_4.0.0        flowCore_2.20.0      flowWorkspace_4.20.0 #> [7] openCyto_2.20.1      staRgate_0.99.3      BiocStyle_2.36.0     #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6        xfun_0.53           bslib_0.9.0         #>  [4] htmlwidgets_1.6.4   Biobase_2.68.0      lattice_0.22-7      #>  [7] vctrs_0.6.5         tools_4.5.1         generics_0.1.4      #> [10] stats4_4.5.1        parallel_4.5.1      tibble_3.3.0        #> [13] pkgconfig_2.0.3     data.table_1.17.8   RColorBrewer_1.1-3  #> [16] S7_0.2.0            desc_1.4.3          S4Vectors_0.46.0    #> [19] gt_1.1.0            graph_1.86.0        lifecycle_1.0.4     #> [22] compiler_4.5.1      farver_2.1.2        stringr_1.5.2       #> [25] textshaping_1.0.4   janitor_2.2.1       snakecase_0.11.1    #> [28] litedown_0.7        htmltools_0.5.8.1   sass_0.4.10         #> [31] yaml_2.3.10         pillar_1.11.1       pkgdown_2.1.3       #> [34] hexbin_1.28.5       jquerylib_0.1.4     tidyr_1.3.1         #> [37] cachem_1.1.0        RProtoBufLib_2.20.0 commonmark_2.0.0    #> [40] tidyselect_1.2.1    digest_0.6.37       stringi_1.8.7       #> [43] dplyr_1.1.4         purrr_1.1.0         bookdown_0.45       #> [46] labeling_0.4.3      flowClust_3.46.0    fastmap_1.2.0       #> [49] grid_4.5.1          cli_3.6.5           magrittr_2.0.4      #> [52] utf8_1.2.6          RBGL_1.84.0         XML_3.99-0.19       #> [55] withr_3.0.2         scales_1.4.0        timechange_0.3.0    #> [58] lubridate_1.9.4     rmarkdown_2.30      matrixStats_1.5.0   #> [61] gridExtra_2.3       cytolib_2.20.0      ragg_1.5.0          #> [64] evaluate_1.0.5      knitr_1.50          markdown_2.0        #> [67] rlang_1.1.6         Rcpp_1.1.0          glue_1.8.0          #> [70] xml2_1.4.0          Rgraphviz_2.52.0    BiocManager_1.30.26 #> [73] BiocGenerics_0.54.1 jsonlite_2.0.0      R6_2.6.1            #> [76] plyr_1.8.9          systemfonts_1.3.1   fs_1.6.6"},{"path":"https://leejasme.github.io/staRgate/articles/vignette_run_pipeline.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Tutorial: Running the pipeline","text":"G. Finak, J. Frelinger, W. Jiang, E. W. Newell, J. Ramey, M. M. Davis, S. . Kalams, S. C. De Rosa R. Gottardo, “OpenCyto: Open Source Infrastructure Scalable, Robust, Reproducible, Automated, End--End Flow Cytometry Data Analysis,” PLoS Computational Biology, vol. 10, p. e1003806, August 2014. G. Finak M. Jiang, “flowWorkspace: Infrastructure representing interacting gated ungated cytometry data sets.,” 2023. G. Finak, W. Jiang R. Gottardo, “CytoML cross-platform cytometry data sharing,” Cytometry Part , vol. 93, pp. -7, 2018. G. Monaco, H. Chen, M. Poidinger, J. Chen, J. P. de Magalhães . Larbi, “flowAI: automatic interactive anomaly discerning tools flow cytometry data,” Bioinformatics, vol. 32, p. 2473–2480, April 2016. P. Van, W. Jiang, R. Gottardo G. Finak, “ggcyto: Next-generation open-source visualization software cytometry,” Bioinformatics, 2018.","code":""},{"path":"https://leejasme.github.io/staRgate/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jasme Lee. Author, maintainer.","code":""},{"path":"https://leejasme.github.io/staRgate/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lee J (2025). staRgate: Automated gating pipeline flow cytometry analysis characterize lineage, differentiation, functional states T-cells. R package version 0.99.3, https://leejasme.github.io/staRgate/.","code":"@Manual{,   title = {staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells},   author = {Jasme Lee},   year = {2025},   note = {R package version 0.99.3},   url = {https://leejasme.github.io/staRgate/}, }"},{"path":"https://leejasme.github.io/staRgate/index.html","id":"stargate","dir":"","previous_headings":"","what":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"density-based automated gating pipeline flow cytometry data characterize lineage, differentiation, functional states T-cells GitHub stores {staRgate} R package.","code":""},{"path":"https://leejasme.github.io/staRgate/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"{staRgate} package relies Biocondcutor R packages. installing {staRgate}, first setup Bioconductor install packages. {flowCore} {flowWorkspace} dependencies {staRgate} package {openCyto}, {flowAI}, {ggcyto} required run functions {staRgate} used full gating pipeline shown Tutorial Please refer Bioconductor full details installation guidelines install staRgate (currently install GitHub):","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") devtools::install_github(\"leejasme/staRgate\")"},{"path":"https://leejasme.github.io/staRgate/index.html","id":"tutorial","dir":"","previous_headings":"","what":"Tutorial","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"full example run pipeline webpage","code":""},{"path":"https://leejasme.github.io/staRgate/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells","text":"Jasme Lee (leej22@mskcc.org)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"csv file path_biexp_params specify channels apply transformation parameters (negative decades, width basis positive decades). default negative decades=0.5, width basis=-30 positive decades=4.5. Transformation can applied subset channels included GatingSet.","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"","code":"getBiexpTransformGS(gs, path_biexp_params)"},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"gs GatingSet apply Biexponential Transformation path_biexp_params file path .csv file specifies Biexponential Transformation","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"GatingSet Biexponentially Transformed data","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"example table provided extdata/biexp_transf_parameters_x50.csv","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getBiexpTransformGS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Applies Biexpeonential Transformation using specifications in csv file provided at path_biexp_params — getBiexpTransformGS","text":"","code":"# This example does not contain all the pre-processing steps required in # getting the GatingSet (gs) ready for Biexp transformation. # To see the steps that are required to creating the (gs), # please see the vignette for a full tutorial  # To make this a runnable example, read in the FCS file to create gs and # directly apply  # File path to the FCS file path_fcs <- system.file(\"extdata\",                         \"example_fcs.fcs\",                         package=\"staRgate\",                         mustWork=TRUE) path_biexp_params <- system.file(\"extdata\",                                  \"biexp_transf_parameters_x50.csv\",                                  package=\"staRgate\",                                  mustWork=TRUE)  # Create a cytoset then convert to gs cs <- flowWorkspace::load_cytoset_from_fcs(path_fcs) gs <- flowWorkspace::GatingSet(cs)  # gs must be a GatingSet object gs <- getBiexpTransformGS(gs, path_biexp_params=path_biexp_params)  # To check the transformation parameters applied flowWorkspace::gh_get_transformations(gs) #> $`AF700-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7b9830> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`APC-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7b7fe8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`APC-f750-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7ba838> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BB515-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7befa8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BB660-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7c2930> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BB700-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7c1350> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BB790-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7c3ba0> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV395-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7c6150> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV496-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7c4b70> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV563-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7cb170> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV615-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7cddb8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV661-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7d0608> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV737-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7cf028> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BUV805-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7d1610> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV421-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7d3e60> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV480-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7d8df0> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV510-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7dfd00> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV570-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7de720> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV605-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7e0f70> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV650-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7e3558> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV711-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7e5da8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV750-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7e4790> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`BV786-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7e8c98> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7eb4b0> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-CF594-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7e9ed0> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-Cy5-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7ec4b8> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-Cy5.5-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7eed08> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>  #> $`PE-Cy7-A` #> function (x, deriv = 0)  #> { #>     deriv <- as.integer(deriv) #>     if (deriv < 0 || deriv > 3)  #>         stop(\"'deriv' must be between 0 and 3\") #>     if (deriv > 0) { #>         z0 <- double(z$n) #>         z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b, b = 2 *  #>             z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d,  #>             c = z0), list(y = 6 * z$d, b = z0, c = z0)) #>         z[[\"d\"]] <- z0 #>     } #>     res <- stats:::.splinefun(x, z) #>     if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>         res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>     res #> } #> <bytecode: 0x556b7a64d988> #> <environment: 0x556b7b7f1558> #> attr(,\"type\") #> [1] \"biexp\" #> attr(,\"parameters\") #> attr(,\"parameters\")$channelRange #> [1] 4096 #>  #> attr(,\"parameters\")$maxValue #> [1] 262144 #>  #> attr(,\"parameters\")$neg #> [1] 0.5 #>  #> attr(,\"parameters\")$pos #> [1] 4.5 #>  #> attr(,\"parameters\")$widthBasis #> [1] -30 #>  #>"},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"csv file path_comp_mat specify channels apply compensation . format matrix col row names correspond channel names","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"","code":"getCompGS(gs, path_comp_mat)"},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"gs GatingSet apply Biexponential Transformation path_comp_mat file path .csv file specifies Compensation Matrix","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"GatingSet compensated data","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"example matrix provided extdata/comp_mat_example_fcs.csv","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getCompGS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Applies Compensation using specifications in csv file provided at path_comp_mat — getCompGS","text":"","code":"# This example does not contain all the pre-processing steps required in # getting the GatingSet (gs) ready for compensation step # To see the steps that are required to creating the (gs), # please see the vignette for a full tutorial  # To make this a runnable example, read in the FCS file to create gs and # directly apply  # File path to the FCS file path_fcs <- system.file(\"extdata\",                         \"example_fcs.fcs\",                         package=\"staRgate\",                         mustWork=TRUE)  path_biexp_params <- system.file(\"extdata\",                                  \"biexp_transf_parameters_x50.csv\",                                  package=\"staRgate\",                                  mustWork=TRUE)  # Create a cytoset then convert to gs cs <- flowWorkspace::load_cytoset_from_fcs(path_fcs) gs <- flowWorkspace::GatingSet(cs)  path_comp_mat <- system.file(\"extdata\", \"comp_mat_example_fcs.csv\",                              package=\"staRgate\", mustWork=TRUE)  # gs is a GatingSet object gs <- getCompGS(gs, path_comp_mat=path_comp_mat)  # Checks the comp mat was successfully applied flowWorkspace::gh_get_compensations(gs) #> Compensation object 'defaultCompensation': #>                 AF700-A        APC-A   APC-f750-A      BB515-A      BB660-A #> AF700-A     1.00000e+00  2.48301e-02  2.49284e-01  0.009679220  2.68438e-03 #> APC-A       1.32334e-01  1.00000e+00  3.37338e-02 -0.000160633  1.59855e-02 #> APC-f750-A  8.68539e-02  1.38732e-01  1.00000e+00 -0.001767070  2.22729e-03 #> BB515-A    -1.15670e-06  8.78380e-06 -3.46330e-06  1.000000000  7.37752e-03 #> BB660-A     8.87227e-02  5.93124e-01  2.00381e-02  0.014618200  1.00000e+00 #> BB700-A     1.56721e-01  1.03493e-01  5.16101e-02  0.021794700  2.37588e-01 #> BB790-A     7.68727e-03  1.93003e-02  3.49874e-02  0.052883600  7.10995e-02 #> BUV395-A   -3.97306e-05 -9.08601e-05 -4.80121e-05 -0.000354928 -3.02965e-04 #> BUV496-A   -1.70875e-04 -1.56429e-04 -7.28591e-05  0.095776400  1.33785e-03 #> BUV563-A   -3.03929e-05  1.56211e-05 -6.56100e-06  0.001668360  2.42316e-02 #> BUV615-A    1.88377e-03  1.04649e-02  4.46188e-04 -0.000136853  8.65835e-03 #> BUV661-A    7.16728e-02  4.13412e-01  1.59599e-02  0.000211115  1.44842e-02 #> BUV737-A    9.29380e-02  1.71690e-03  4.01840e-02 -0.000194453  1.74362e-04 #> BUV805-A    1.48820e-03  2.44068e-04  2.91305e-02 -0.000338491 -4.23913e-05 #> BV421-A    -4.58681e-05 -3.74460e-05  4.48270e-06 -0.000231336 -1.08696e-04 #> BV480-A    -3.92074e-05 -3.39299e-04 -1.30588e-04  0.074170000  1.02894e-03 #> BV510-A     3.99142e-05  3.73202e-05  9.80330e-06  0.007911250  5.75615e-04 #> BV570-A    -1.95859e-05 -4.32965e-05 -2.69880e-05 -0.000243723  3.05622e-02 #> BV605-A     3.73103e-04  2.83992e-03  5.74537e-05 -0.000398720  2.06667e-02 #> BV650-A     2.49470e-02  1.41986e-01  5.86113e-03 -0.000144804  7.52309e-03 #> BV711-A     1.42797e-01  7.78301e-03  4.29540e-02 -0.000232658  5.99928e-04 #> BV750-A     2.67505e-02 -1.90386e-04  3.20051e-02 -0.000578142 -4.42366e-04 #> BV786-A     5.43321e-03  8.58750e-04  4.07434e-02 -0.000103106 -1.87470e-04 #> PE-A        2.42350e-06  4.56944e-05  1.70525e-05  0.001072310  1.07968e-01 #> PE-CF594-A  1.22079e-04  1.15465e-03  1.97960e-05  0.000422330  1.59573e-01 #> PE-Cy5-A    5.44479e-02  2.99784e-01  1.38827e-02  0.000808311  7.99483e-01 #> PE-Cy5.5-A  5.43460e-02  2.06764e-02  1.80785e-02  0.001296560  9.39576e-02 #> PE-Cy7-A    2.68890e-03  9.69828e-04  2.59495e-02  0.002524130  9.41381e-03 #>                 BB700-A     BB790-A    BUV395-A     BUV496-A     BUV563-A #> AF700-A     4.73248e-02 1.73077e-02 0.001813870  1.81722e-03  1.45041e-03 #> APC-A       4.43383e-03 1.22597e-03 0.000471851 -5.18352e-05 -3.25396e-05 #> APC-f750-A  1.35711e-03 5.27278e-02 0.007016350 -3.55365e-04 -1.00153e-03 #> BB515-A     1.60540e-03 2.59797e-04 0.000488654  9.92731e-03  2.45334e-03 #> BB660-A     2.99259e-01 7.25687e-02 0.000750601  4.69872e-04  5.91621e-03 #> BB700-A     1.00000e+00 3.05046e-01 0.001371840  5.33863e-04  7.68645e-03 #> BB790-A     5.02619e-02 1.00000e+00 0.002098810  2.45469e-03  1.13829e-02 #> BUV395-A   -1.53987e-04 3.18150e-06 1.000000000  5.54187e-02  7.64453e-03 #> BUV496-A   -4.51891e-05 6.25497e-05 0.098747400  1.00000e+00  3.65217e-01 #> BUV563-A    6.00392e-03 1.02481e-03 0.057067000  1.35061e-02  1.00000e+00 #> BUV615-A    2.94497e-03 5.66486e-04 0.014661800  2.36745e-03  1.27502e-01 #> BUV661-A    5.32708e-03 1.11836e-03 0.020613000  4.04929e-03  3.19467e-03 #> BUV737-A    6.05855e-02 5.83387e-02 0.045702600  8.07775e-03  2.91077e-03 #> BUV805-A    6.19200e-06 7.86824e-03 0.152528000  2.55410e-02  8.81890e-03 #> BV421-A    -2.56252e-05 2.24736e-05 0.001380780  2.03413e-02  3.32902e-03 #> BV480-A     1.24956e-04 3.73860e-05 0.003972760  1.50035e-01  5.40699e-02 #> BV510-A     1.83050e-04 6.42423e-05 0.000832350  1.42374e-01  7.81014e-02 #> BV570-A     8.98102e-03 1.67519e-03 0.002127950  2.19612e-03  3.36621e-01 #> BV605-A     6.32870e-03 1.46373e-03 0.001450870  3.21298e-04  1.24272e-01 #> BV650-A     2.49028e-03 4.20274e-04 0.000569780  5.27449e-04  1.52040e-03 #> BV711-A     5.23583e-02 2.12145e-02 0.001247390  1.21889e-03  3.18952e-04 #> BV750-A     1.41867e-02 5.33999e-02 0.002543330  1.71614e-03  8.49586e-04 #> BV786-A     7.40567e-04 3.27007e-02 0.002449540  2.19287e-03  1.40705e-03 #> PE-A        2.49105e-02 4.41402e-03 0.000817685  1.55200e-07  1.43966e-01 #> PE-CF594-A  3.54211e-02 6.29059e-03 0.000360426 -1.55097e-05  1.97198e-02 #> PE-Cy5-A    4.23019e-01 1.00346e-01 0.000627548 -3.54997e-05  1.16335e-03 #> PE-Cy5.5-A  8.58340e-01 2.62780e-01 0.000837972 -6.29106e-05  1.20731e-02 #> PE-Cy7-A    1.58009e-02 7.96257e-01 0.000479509  4.18652e-05  3.30418e-03 #>               BUV615-A    BUV661-A     BUV737-A     BUV805-A      BV421-A #> AF700-A    0.002494550 0.002203370  1.38716e-01  3.31042e-02  5.11994e-05 #> APC-A      0.001271670 0.114363000  2.21613e-02  5.27436e-03 -4.09868e-04 #> APC-f750-A 0.000055023 0.013948700  3.17988e-02  2.49248e-01 -7.88098e-03 #> BB515-A    0.001525590 0.000265054 -1.52650e-06 -1.18940e-05 -3.13395e-04 #> BB660-A    0.013022400 0.199251000  3.28067e-02  8.41315e-03 -8.18947e-04 #> BB700-A    0.012374800 0.042845800  1.02680e-01  3.47818e-02 -1.40587e-03 #> BB790-A    0.016154000 0.014608200  4.38512e-02  2.00196e-01  3.00000e-02 #> BUV395-A   0.004780480 0.001071850  1.18867e-04  1.02188e-04  2.78182e-03 #> BUV496-A   0.268124000 0.062647400  7.57148e-03  2.09299e-03 -5.20714e-04 #> BUV563-A   0.801998000 0.176471000  1.60286e-02  4.16364e-03  1.75302e-04 #> BUV615-A   1.000000000 0.308511000  4.42630e-02  1.07449e-02 -2.39673e-04 #> BUV661-A   0.050497000 1.000000000  1.79399e-01  4.21779e-02 -2.48790e-04 #> BUV737-A   0.006115390 0.007730770  1.00000e+00  3.35491e-01 -6.34979e-04 #> BUV805-A   0.009796310 0.003424230  2.00370e-02  1.00000e+00  7.80230e-04 #> BV421-A    0.002006550 0.000352226 -3.83712e-05 -9.46220e-06  1.00000e+00 #> BV480-A    0.044346200 0.011099600  1.18442e-03  9.03918e-05  3.28934e-02 #> BV510-A    0.058545300 0.013467900  1.60638e-03  4.70613e-04  3.12078e-02 #> BV570-A    0.325082000 0.093851200  1.18768e-02  3.12652e-03  2.94131e-01 #> BV605-A    0.432763000 0.188787000  2.95693e-02  8.92535e-03  6.39988e-02 #> BV650-A    0.063496300 0.379917000  5.09028e-02  1.20807e-02  7.45601e-02 #> BV711-A    0.000281952 0.008343360  3.58429e-01  1.20486e-01  1.75048e-01 #> BV750-A    0.000697057 0.000228257  3.97713e-01  2.31938e-01  1.64162e-01 #> BV786-A    0.001364530 0.001438030  8.33593e-02  4.37018e-01  2.18063e-01 #> PE-A       0.084587700 0.019890000  1.79239e-03  3.72104e-04 -8.61543e-04 #> PE-CF594-A 0.089092500 0.022101900  2.17152e-03  4.54470e-04 -4.12173e-04 #> PE-Cy5-A   0.000960021 0.108923000  2.85432e-02  6.31031e-03 -7.45224e-04 #> PE-Cy5.5-A 0.007263900 0.013356100  5.52763e-02  1.95809e-02 -9.63066e-04 #> PE-Cy7-A   0.002259690 0.001000860  1.43824e-02  7.63386e-02  3.96796e-05 #>                BV480-A     BV510-A      BV570-A     BV605-A      BV650-A #> AF700-A    3.39020e-03 2.60901e-03  2.45899e-03 3.58515e-03  4.45768e-03 #> APC-A      1.13668e-04 4.37466e-05  5.85607e-05 8.50790e-04  1.38441e-01 #> APC-f750-A 3.11889e-03 1.52763e-03 -9.31873e-04 1.73277e-04  1.63506e-02 #> BB515-A    1.90708e-04 3.34812e-03  8.84301e-04 5.79157e-04  1.26033e-04 #> BB660-A    3.88549e-04 2.12014e-03  2.71519e-02 4.90954e-02  6.92174e-01 #> BB700-A    5.86408e-04 3.01256e-03  3.65599e-02 5.91123e-02  1.73298e-01 #> BB790-A    1.37380e-02 4.94921e-03  2.97942e-02 4.35257e-02  4.88238e-02 #> BUV395-A   2.08318e-03 4.76822e-04  1.52133e-04 2.53224e-05 -8.20849e-05 #> BUV496-A   7.39427e-02 1.11638e-01  4.81571e-02 3.82096e-02  1.08770e-02 #> BUV563-A   7.79602e-04 2.83422e-04  3.19227e-02 2.53748e-02  6.98563e-03 #> BUV615-A   3.08100e-04 1.58664e-04  6.17956e-03 5.29439e-02  2.51154e-02 #> BUV661-A   4.93886e-04 1.92803e-04  2.63330e-04 1.72809e-03  8.21198e-02 #> BUV737-A   1.00461e-03 5.70701e-04  1.28647e-04 1.30938e-04  1.68492e-04 #> BUV805-A   2.35894e-03 5.99444e-04  4.38039e-04 2.38396e-04  2.55093e-05 #> BV421-A    2.59112e-01 3.43013e-02  7.07011e-03 5.16549e-03  1.39979e-03 #> BV480-A    1.00000e+00 5.09955e-01  2.08648e-01 1.83489e-01  5.17878e-02 #> BV510-A    5.11981e-01 1.00000e+00  5.85075e-01 4.57877e-01  1.17909e-01 #> BV570-A    7.71052e-02 1.05009e-02  1.00000e+00 9.38126e-01  3.66694e-01 #> BV605-A    1.67879e-02 2.43152e-03  2.71032e-01 1.00000e+00  5.59945e-01 #> BV650-A    1.96639e-02 2.67944e-03  4.09261e-03 1.02064e-01  1.00000e+00 #> BV711-A    4.55151e-02 6.38200e-03  1.93257e-03 1.81694e-03  2.58669e-02 #> BV750-A    4.39226e-02 6.76290e-03  3.32289e-03 3.69302e-03  2.25377e-03 #> BV786-A    5.73902e-02 8.97809e-03  4.39112e-03 5.06660e-03  6.18139e-03 #> PE-A       2.07971e-04 1.01976e-04  1.85304e-01 1.11878e-01  3.29431e-02 #> PE-CF594-A 9.85278e-05 3.54644e-05  2.32778e-02 1.02543e-01  3.57088e-02 #> PE-Cy5-A   1.89136e-04 9.74498e-05  1.61336e-03 1.27491e-03  1.77067e-01 #> PE-Cy5.5-A 2.70537e-04 1.59472e-04  1.65944e-02 1.04537e-02  2.36452e-02 #> PE-Cy7-A   2.81302e-04 1.48387e-04  4.82638e-03 3.54159e-03  2.06083e-03 #>                 BV711-A      BV750-A      BV786-A         PE-A   PE-CF594-A #> AF700-A     2.12730e-01  8.48399e-02  4.39476e-02  0.006840740  2.92636e-02 #> APC-A       2.85134e-02  9.73321e-03  4.17643e-03  0.000280757  5.41964e-03 #> APC-f750-A  5.86523e-03  6.38759e-02  2.26547e-01 -0.002460560  7.43340e-03 #> BB515-A     8.56130e-06 -1.02317e-05 -1.94972e-05 -0.000126331 -7.83382e-05 #> BB660-A     1.61692e-01  4.23041e-02  2.02054e-02  0.000124760  1.78335e-03 #> BB700-A     5.56872e-01  1.49641e-01  8.27345e-02  0.000280215  7.49651e-04 #> BB790-A     2.75898e-02  1.57377e-01  3.20000e-01  0.007845450  8.33031e-03 #> BUV395-A   -1.58152e-04  2.35720e-06 -4.73557e-05 -0.000820269 -5.78163e-04 #> BUV496-A    1.77501e-03  1.90057e-04 -3.06013e-04 -0.002193560 -1.56496e-03 #> BUV563-A    1.41310e-03  2.22890e-04  7.99360e-05  0.596597000  3.61606e-01 #> BUV615-A    6.40066e-03  1.53283e-03  6.37276e-04  0.150273000  5.24636e-01 #> BUV661-A    2.12455e-02  5.33407e-03  2.37470e-03  0.000904487  8.15890e-03 #> BUV737-A    2.89365e-02  3.30411e-02  1.64371e-02 -0.000219964  1.09293e-03 #> BUV805-A   -5.49240e-05  1.45854e-03  3.18866e-02  0.000166491  9.85399e-04 #> BV421-A     3.43802e-04  1.06304e-04  6.16866e-05 -0.000634983 -4.00289e-04 #> BV480-A     1.07909e-02  2.23720e-03  7.71069e-04 -0.002727040 -1.37957e-03 #> BV510-A     1.98026e-02  4.38332e-03  2.06777e-03  0.000734193  7.17537e-04 #> BV570-A     7.93858e-02  1.87543e-02  8.92960e-03  0.765370000  5.54055e-01 #> BV605-A     1.29191e-01  3.40905e-02  1.78946e-02  0.254213000  4.53597e-01 #> BV650-A     2.49314e-01  5.54632e-02  2.49019e-02  0.001398340  1.56155e-02 #> BV711-A     1.00000e+00  3.53401e-01  2.29209e-01 -0.000155164 -1.08140e-04 #> BV750-A     2.69688e-01  1.00000e+00  5.20676e-01 -0.001100440 -4.67482e-04 #> BV786-A     2.94720e-02  3.83526e-01  1.00000e+00 -0.000328190  2.38060e-06 #> PE-A        6.48352e-03  1.12158e-03  4.41299e-04  1.000000000  5.14498e-01 #> PE-CF594-A  6.01004e-03  1.32874e-03  5.20298e-04  0.416582000  1.00000e+00 #> PE-Cy5-A    6.54580e-02  1.78464e-02  7.15173e-03  0.039473100  2.31414e-02 #> PE-Cy5.5-A  1.60747e-01  4.01366e-02  2.26926e-02  0.247869000  1.32105e-01 #> PE-Cy7-A    2.53419e-03  3.97731e-02  9.87322e-02  0.102724000  5.67300e-02 #>                PE-Cy5-A   PE-Cy5.5-A     PE-Cy7-A #> AF700-A     1.64829e-02  3.26051e-01  1.03233e-01 #> APC-A       2.67747e-01  8.10869e-02  2.15633e-02 #> APC-f750-A  4.93700e-02  2.25955e-02  6.09145e-01 #> BB515-A    -6.68526e-05 -3.01727e-05 -1.21999e-05 #> BB660-A     7.25687e-02  2.16664e-02  5.19117e-03 #> BB700-A     2.13325e-02  6.47322e-02  1.92574e-02 #> BB790-A     5.86199e-03  2.73473e-03  2.39552e-02 #> BUV395-A   -3.16921e-04 -1.94081e-04 -6.82352e-05 #> BUV496-A   -1.03874e-03 -7.87568e-04 -3.83751e-04 #> BUV563-A    5.34820e-02  1.18256e-02  2.30218e-03 #> BUV615-A    1.27041e-01  3.87130e-02  8.33019e-03 #> BUV661-A    1.29609e-01  4.69461e-02  9.83433e-03 #> BUV737-A    1.05708e-03  1.55556e-02  1.20126e-02 #> BUV805-A    2.41638e-05  8.65425e-05  9.39790e-03 #> BV421-A    -1.95171e-04 -7.76933e-05 -3.45835e-05 #> BV480-A    -8.99502e-04 -5.11925e-04 -3.20846e-04 #> BV510-A     3.09406e-04  1.02978e-04  6.77227e-05 #> BV570-A     1.09151e-01  2.85402e-02  6.54611e-03 #> BV605-A     1.21365e-01  3.52925e-02  9.52471e-03 #> BV650-A     7.23832e-02  2.28208e-02  4.93623e-03 #> BV711-A     1.44939e-03  2.94488e-02  1.10223e-02 #> BV750-A    -4.54062e-04  3.00004e-03  1.08283e-02 #> BV786-A     1.12239e-04  3.95568e-04  1.78838e-02 #> PE-A        8.31948e-02  1.84931e-02  3.40669e-03 #> PE-CF594-A  1.72793e-01  3.80472e-02  7.03978e-03 #> PE-Cy5-A    1.00000e+00  4.91045e-01  1.20956e-01 #> PE-Cy5.5-A  2.33135e-01  1.00000e+00  3.02046e-01 #> PE-Cy7-A    1.23589e-02  2.26059e-02  1.00000e+00"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"Internal function get_density_gates unique value subset_col, estimate derivatives marker (intensity values)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"","code":"getDensityDerivs(   dens,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"dens density object density marker string marker gate name needs match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak default 1800, biexponential scale","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityDerivs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Estimate derivatives for density of marker for each unique subset of subset_col — getDensityDerivs","text":"list dataframe density estimation corresponding 1st-4th derivatives, indicators local peaks, plateau_pre  element corresponds unique value subset_col  dataframe: rows correspond bins","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":null,"dir":"Reference","previous_headings":"","what":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"unique value subset_col, gate using density estimated derivatives identify cutoff shoulder (.e., point tapering ) relative peak marker (intensity values). strategy cutting shoulder mimics strategy gate relative unimodal background negative subpopulation, capable capturing dim subpopulations.","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"","code":"getDensityGates(   intens_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800,   neg_intensity_threshold = -1000 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, openCyto steps) intensity values cols=intensity value per marker, rows=sample marker string marker(s) gate names need match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n=bin_n) number equally spaced points density estimated  Default 512, default density(n=512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored  Default=10 pos_peak_threshold either: numeric threshold identify positive peak dataframe supplying multiple marker gate. dataframe needs supplied 2 columns named marker pos_peak_threshold rows marker gate Default 1800 (note biexponential scale) marker neg_intensity_threshold numeric threshold filter \"negatively\" expressed cells density estimation avoid -compression difficulty distinguishing peaks gates  applied filter density estimation, cells < neg_intensity_threshold retained intensity matrix steps  Expects neg_intensity_threshold scale transformed data intens_dat  Default NULL: filters applied density estimation based cells corresponding subsets. Suggested biexp. transformed data -1000 corresponds ~-3300 original intensity scale)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"tibble gates/cutoffs marker unique subset found subset_col rows correspond unique values subset_col , columns correspond tomarker","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityGates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density gating of intensity values in marker for each unique subset of subset_col — getDensityGates","text":"","code":"# Create a fake dataset set.seed(100) intens_dat<-tibble::tibble(                CD3_pos=rep(c(0, 1), each=50),                CD4=rnorm(100, 100, 10),                CD8=rnorm(100, 100, 10) )  # Run density gating, leaving other params at suggested defaults # number of bins suggested is 40 but default is at `bin_n=512`, # which is the default for the R base density() function getDensityGates(intens_dat, marker=\"CD4\", subset_col=\"CD3_pos\", bin_n=40) #> # A tibble: 2 × 2 #>   CD3_pos   CD4 #>     <dbl> <dbl> #> 1       0  88.9 #> 2       1 113."},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"Internal function getDensityGates unique value subset_col, matrix storing calculations density gating contains: first fourth derivatives density, indicators local peaks, \"real peaks\", plateau_pre cutoff","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"","code":"getDensityMats(   intens_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800 )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, gated CD4/CD8) intensity values cols = intensity value per marker, rows = sample marker string marker gate name needs match exactly column name intens_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak '  default 1800, biexponential scale","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityMats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Matrix of calculations for density gating of intensity values in marker for each unique subset of subset_col — getDensityMats","text":"tibble matrices marker containing calculations density gating unique subset found subset_col  rows correspond unique values subset_col,  cols correspond information density gating","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function: Determine the ","title":"Internal function: Determine the ","text":"Internal function getDensityGates","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function: Determine the ","text":"","code":"getDensityPeakCutoff(   dens_binned_dat,   marker,   subset_col,   bin_n = 512,   peak_detect_ratio = 10,   pos_peak_threshold = 1800,   dens_flip = FALSE )"},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function: Determine the ","text":"dens_binned_dat list dataframe output getDensityDerivs marker string marker gate name needs match exactly column name dens_binned_dat subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column bin_n numeric passed n parameter density(n = bin_n) number equally spaced points density estimated default 512, default density(n = 512) peak_detect_ratio numeric threshold eliminating small peaks peak < highest peak peak_detect_ratio times ignored default = 10 pos_peak_threshold numeric threshold identify positive peak default 1800, biexponential scale dens_flip logical whether gating applied \"backwards\" peak positive peak want gate left peak instead right","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getDensityPeakCutoff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function: Determine the ","text":"list dataframe dens_binned_dat additional columns added peak(s) identified cutoff element corresponds unique value subset_col dataframe: rows correspond bins","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"Adds indicator column (0/1) intens_dat marker cutoffs indicated columns cutoffs","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"","code":"getGatedDat(intens_dat, cutoffs, subset_col)"},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"intens_dat dataframe pre-gated (compensated, biexp. transf, openCyto steps) intensity values rows=cell cols intensity values marker cutoffs tibble gates/cutoffs markers gate  Expects cutoffs match format output getDensityGates() column corresponding marker, rows subsets defined subset_col subset_col string column name indicate subsets apply density gating perform operation subsets corresponding unique value column","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"intens_dat additional columns attached marker cutoffs","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"naming convention tagged indicator columns tolower(<marker_name>_pos) 0 indicates negativity intensity < gate provided 1 indicates positivity intensity > gate provided","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getGatedDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Attach indicator columns to intens_dat based on gates provided in cutoffs — getGatedDat","text":"","code":"# Create a fake dataset set.seed(100) intens_dat <- tibble::tibble(                CD3_pos=rep(c(0, 1), each=50),                CD4=rnorm(100, 100, 10),                CD8=rnorm(100, 100, 10) )  # Run getDensityGates to obtain the gates gates <- getDensityGates(intens_dat, marker=\"CD4\", subset_col=\"CD3_pos\", bin_n=40)  # Tag on the 0/1 on intens_dat intens_dat_2 <- getGatedDat(intens_dat, cutoffs=gates, subset_col=\"CD3_pos\")  # intens_dat_2 now has the cd4_pos tagged on head(intens_dat_2) #> # A tibble: 6 × 4 #>   CD3_pos   CD4   CD8 cd4_pos #>     <dbl> <dbl> <dbl>   <dbl> #> 1       0  95.0  96.7       1 #> 2       0 101.  114.        1 #> 3       0  99.2  95.3       1 #> 4       0 109.  108.        1 #> 5       0 101.   85.4       1 #> 6       0 103.   96.0       1"},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the percentage of positive cells for specific subpopulations — getPerc","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"Expects data input output get_gated_dat indicator columns specific naming convention (see ).","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"","code":"getPerc(   intens_dat,   num_marker,   denom_marker,   expand_num = FALSE,   expand_denom = FALSE,   keep_indicators = TRUE )"},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"intens_dat dataframe gated data indicator columns per marker interest (specify num_marker denom_marker) naming convention marker_pos per marker values 0 indicate negative-, 1 indicate positive-expressing num_marker string marker(s) specify numerator subpopulations interest  See expand_num argument examples specify denom_marker string marker(s) specify denominator subpopulations interest  See expand_denom argument examples specify. expand_num logical, accepts TRUE FALSE default FALSE  expand_num=TRUE, currently considers pairs markers specified num_marker numerator subpopulation calculations (e.g., CD4+ & CD8- CD3+)  expand_num=FALSE, considers marker specified num_marker individually numerator subpopulation calculations (e.g., CD4+ CD3+) expand_denom logical, accepts TRUE FALSE default FALSE  expand_denom=TRUE, currently considers 1 marker num_marker unique combinations denom_marker generate list subpopulations  e.g., denom_marker=c(\"CD8\"), num_marker=c(\"LAG3\", \"KI67\"), expand_denom=TRUE, subpopulations include:  1. LAG3+ CD8+, LAG3- CD8+, LAG3+ CD8-, LAG3- CD8-,  2. KI67+ CD8+, KI67- CD8+, KI67+ CD8-, KI67- CD8-,  3. KI67+ (LAG3+ & CD8+), KI67- (LAG3+ & CD8+), KI67+ (LAG3+ & CD8-), KI67- (LAG3+ & CD8-)...etc.,  4. LAG3+ (KI67+ & CD8+), LAG3- (KI67+ & CD8+), LAG3+ (KI67+ & CD8-), LAG3- (KI67+ & CD8-)...etc.,  expand_denom=FALSE, generates list subpopulations based unique combinations denom_marker (e.g., denom_marker=c(\"CD4\") expand_denom=FALSE considers subpopulations denominator CD4+ CD4- whereas denom_marker=c(\"CD4\", \"CD8\" expand_denom=FALSE consider subpopulations denominators (CD4- & CD8-), (CD4+ & CD8-), (CD4- & CD8+) (CD4+ & CD8+)) keep_indicators logical, accepts TRUE FALSE default TRUE  keep_indicators=TRUE, return indicator columns 0/1 specify markers considered numerator denominators subpopulations.   Naming convention numerator cols <marker>_POS denominator cols <marker>_POS_D.  sets columns, 0 indicates considered negative cells, 1 indicates considered positive cells NA_real_ indicates consideration subpopulation.   useful matching percentage data potentially different naming conventions avoid exact string matches subpopulation  Take note order also matters matching strings: \"CD4+ & CD8- CD3+\" different \"CD8- & CD4+ CD3+\"","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"tibble containing percentage cells rows correspond subpopulation specified subpopulation, n_num indicates number cells satisifies numerator conditions, n_denom indicates number cells satisifies denominator conditions, perc=n_num divided n_denom unless n_denom=0, perc=NA_real_","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"subpopulations defined (num marker(s)) (denom marker(s)) num denotes numerator, denom denotes denominator (shorthands used function arguments)","code":""},{"path":"https://leejasme.github.io/staRgate/reference/getPerc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the percentage of positive cells for specific subpopulations — getPerc","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  # Create a fake dataset set.seed(100) intens_dat <- tibble::tibble(                CD3_pos=rep(c(0, 1), each=50),                CD4=rnorm(100, 100, 10),                CD8=rnorm(100, 100, 10) )  # Run getDensityGates to obtain the gates gates <- getDensityGates(intens_dat, marker=\"CD4\", subset_col=\"CD3_pos\", bin_n=40)  # Tag on the 0/1 on intens_dat intens_dat_2 <- getGatedDat(intens_dat, cutoffs=gates, subset_col=\"CD3_pos\")  # Get percentage for CD4 based on gating getPerc(intens_dat_2, num_marker=c(\"CD4\"), denom_marker=\"CD3\") #> # A tibble: 4 × 6 #>   subpopulation      n_num n_denom  perc CD4_POS CD3_POS_D #>   <chr>              <int>   <int> <dbl>   <dbl>     <dbl> #> 1 CD4_NEG_OF_CD3_NEG     3      50     6       0         0 #> 2 CD4_POS_OF_CD3_NEG    47      50    94       1         0 #> 3 CD4_NEG_OF_CD3_POS    42      50    84       0         1 #> 4 CD4_POS_OF_CD3_POS     8      50    16       1         1"},{"path":"https://leejasme.github.io/staRgate/reference/staRgate-package.html","id":null,"dir":"Reference","previous_headings":"","what":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","title":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","text":"R-based automated gating pipeline flow cytometry data designed mimic manual gating strategy defining flow biomarker positive populations relative unimodal background population include cells varying intensities marker expression. pipeline’s main feature flexible density-based gating strategy capable capturing varying scenarios based marker expression patterns analyze 29-marker flow panel characterizes T-cell lineage, differentiation, functional states.","code":""},{"path":[]},{"path":"https://leejasme.github.io/staRgate/reference/staRgate-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"staRgate: Automated gating pipeline for flow cytometry analysis to characterize the lineage, differentiation, and functional states of T-cells — staRgate-package","text":"Maintainer: Jasme Lee leej22@mskcc.org (ORCID)","code":""}]
